{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Next.js 14 Project with TypeScript and Tailwind CSS",
        "description": "Initialize the project with Next.js 14 using App Router, TypeScript for type safety, and Tailwind CSS for styling.",
        "details": "1. Create a new Next.js project using `npx create-next-app@latest` with TypeScript and Tailwind CSS options\n2. Configure the App Router structure\n3. Set up basic folder structure (app/, components/, lib/, types/, public/)\n4. Configure TypeScript settings in tsconfig.json\n5. Set up Tailwind CSS with appropriate configuration for the project\n6. Create basic layout components (Header, Footer, Layout)\n7. Set up ESLint and Prettier for code quality\n8. Initialize Git repository with appropriate .gitignore",
        "testStrategy": "1. Verify successful build with `npm run build`\n2. Confirm TypeScript compilation works without errors\n3. Test that Tailwind CSS is properly applied\n4. Ensure App Router navigation works between basic pages\n5. Verify responsive layout on multiple screen sizes",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Define Recipe Data Structure and Types",
        "description": "Create TypeScript interfaces and types for recipe data, including categories, ingredients, instructions, and metadata.",
        "details": "1. Define Recipe interface with properties: id, title, description, ingredients, instructions, prepTime, cookTime, servings, categories, nutritionalInfo, images, slug, etc.\n2. Create Category type for recipe categorization\n3. Define NutritionalInfo interface for storing nutrition data\n4. Create utility types for recipe filtering and sorting\n5. Set up validation schemas for recipe data\n6. Document the data structure with JSDoc comments\n7. Create sample recipe data for development",
        "testStrategy": "1. Validate sample recipe data against defined types\n2. Test type compatibility with mock API responses\n3. Verify that all required recipe properties are properly typed\n4. Test edge cases with optional properties\n5. Ensure types support all planned filtering and sorting operations",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Recipe Card and Detail Components",
        "description": "Create reusable React components for displaying recipe cards in listings and detailed recipe information on individual pages, following Arla-inspired design patterns.",
        "status": "in-progress",
        "dependencies": [
          1,
          2
        ],
        "priority": "high",
        "details": "1. Create RecipeCard component with image, title, description, prep time, and category tags\n2. Implement RecipeDetail component with full recipe information\n3. Build IngredientsList and InstructionsList components with floating navigation buttons (Ingredienser first, then Sådan gør du)\n4. Create NutritionalInfo component for displaying nutrition data with serving size adjustment functionality\n5. Implement responsive layouts for all components using Tailwind CSS with mobile-first approach\n6. Add proper accessibility attributes (aria-labels, semantic HTML)\n7. Implement loading states and error handling\n8. Create storybook stories or component documentation\n9. Implement comment system for recipe feedback\n10. Add save/share icons for recipe sharing functionality\n11. Create \"Mine tips til opskriften\" section for user tips\n12. Implement \"Andre gode forslag\" section for related recipes\n13. Add \"Om functionalfoods\" section for educational content\n14. Design clean, modern UI consistent with Arla-inspired aesthetic",
        "testStrategy": "1. Create unit tests for all components using React Testing Library\n2. Test responsive behavior across different screen sizes\n3. Verify accessibility with automated tools (axe, lighthouse)\n4. Test components with various recipe data configurations\n5. Verify proper error state handling with invalid data\n6. Test floating navigation functionality on mobile and desktop\n7. Verify comment system works correctly\n8. Test serving size adjustment calculations\n9. Verify save/share functionality works as expected\n10. Test all new sections render correctly with different content types",
        "subtasks": [
          {
            "id": 1,
            "title": "Create RecipeCard component",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement RecipeDetail component",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "<info added on 2025-08-01T05:38:29.379Z>\nSuccessfully implemented RecipeDetail component with Arla-inspired design featuring floating navigation for Ingredients and Instructions sections. Added nutrition facts box with \"Forstå Keto\" text and serving size adjustment controls. Implemented recipe action buttons (save, share, shopping list) and created sections for recipe tips, related suggestions, and \"Om functionalfoods\". Added comment system, breadcrumbs navigation, star rating, and personal recipe description. All components are modular, reusable, and follow mobile-first responsive design principles with functional foods branding (green colors, keto focus).\n</info added on 2025-08-01T05:38:29.379Z>",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build IngredientsList and InstructionsList with floating navigation",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "<info added on 2025-08-01T06:45:03.903Z>\nSuccessfully implemented dynamic ingredients calculation system with the following features:\n\n- Moved \"Ingredienser\" and \"Sådan gør du\" sections up under serving size adjustment\n- Created DynamicIngredientsList component that automatically calculates ingredient amounts based on serving size\n- Implemented smart unit conversion (dl, g, kg, l, stk, tsk, spsk)\n- Added serving size adjustment that updates ingredient quantities in real-time\n- Maintained proper layout with ingredients on left, instructions on right\n- All calculations are based on original recipe servings vs current servings\n\nThe system now automatically adjusts ingredient quantities when users change the number of servings, making it perfect for recipes that are typically designed for 2 people but need to be scaled up or down.\n</info added on 2025-08-01T06:45:03.903Z>",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create NutritionalInfo component with serving size adjustment",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement comment system",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Add save/share functionality",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Create \"Mine tips til opskriften\" section",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Implement \"Andre gode forslag\" section",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Add \"Om functionalfoods\" section",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Implement mobile-first responsive design",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Set Up Image Optimization Pipeline",
        "description": "Implement image handling infrastructure using Next.js Image component with proper optimization, lazy loading, and responsive sizing.",
        "details": "1. Create OptimizedImage component wrapping Next.js Image\n2. Configure image sizes and quality settings\n3. Implement lazy loading for images\n4. Set up responsive image sizing based on viewport\n5. Create image placeholder/blur-up functionality\n6. Configure image formats (WebP, AVIF support)\n7. Implement error handling for missing images\n8. Create utility functions for image URL generation",
        "testStrategy": "1. Test image loading performance using Lighthouse\n2. Verify lazy loading behavior works correctly\n3. Test responsive image sizing across devices\n4. Validate image optimization metrics (size reduction)\n5. Test fallback behavior for unsupported browsers\n6. Verify error handling with missing or invalid images",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Recipe Listing and Pagination",
        "description": "Create the main recipe listing page with pagination, sorting options, and responsive grid layout.",
        "details": "1. Create RecipeGrid component for displaying recipe cards\n2. Implement pagination component with next/previous controls\n3. Add sorting functionality (newest, popular, alphabetical)\n4. Create responsive grid layout using Tailwind CSS grid\n5. Implement loading states during pagination\n6. Add empty state handling\n7. Optimize for performance with windowing for large lists\n8. Implement URL-based pagination state",
        "testStrategy": "1. Test pagination with various page sizes\n2. Verify sorting functionality works correctly\n3. Test responsive layout across device sizes\n4. Measure and optimize component rendering performance\n5. Test URL-based navigation between pages\n6. Verify accessibility of pagination controls",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Develop Category-Based Recipe Browsing",
        "description": "Implement category-based navigation and filtering for recipes, including category pages and filtering UI.",
        "details": "1. Create CategoryList component for displaying available categories\n2. Implement CategoryPage for showing recipes within a category\n3. Add category filtering on recipe listing pages\n4. Create category tag components for recipe cards\n5. Implement URL-based category filtering\n6. Add breadcrumb navigation for category pages\n7. Create category metadata for SEO purposes\n8. Implement category-based sorting and filtering",
        "testStrategy": "1. Test category filtering with various combinations\n2. Verify URL-based navigation works correctly\n3. Test breadcrumb navigation paths\n4. Verify SEO metadata is correctly generated\n5. Test performance with large category lists\n6. Verify accessibility of category navigation",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Search Functionality with Filters",
        "description": "Create a robust search system with filters for ingredients, categories, cooking time, and other recipe attributes.",
        "details": "1. Implement search input component with autocomplete\n2. Create client-side search algorithm for recipe data\n3. Add filter components for various recipe attributes\n4. Implement combined search and filter logic\n5. Create SearchResults component for displaying results\n6. Add URL-based search state for sharing\n7. Implement search highlighting in results\n8. Add empty state and loading indicators",
        "testStrategy": "1. Test search with various query types (partial words, phrases)\n2. Verify filter combinations work correctly\n3. Test search performance with large recipe datasets\n4. Verify URL-based search state works correctly\n5. Test accessibility of search and filter components\n6. Verify empty state handling works correctly",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Create Admin Authentication System",
        "description": "Implement secure authentication for admin users to access content management features.",
        "details": "1. Set up authentication provider (NextAuth.js recommended)\n2. Create login page with form validation\n3. Implement session management and persistence\n4. Add protected route middleware for admin pages\n5. Create user profile and settings page\n6. Implement password reset functionality\n7. Add security headers and CSRF protection\n8. Create logout functionality",
        "testStrategy": "1. Test authentication flow with valid and invalid credentials\n2. Verify protected routes redirect unauthenticated users\n3. Test session persistence across page reloads\n4. Verify password reset functionality\n5. Test security headers and CSRF protection\n6. Verify proper error handling for authentication failures",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Develop Admin Recipe Management Interface",
        "description": "Create an admin interface for creating, editing, and deleting recipes with form validation and preview functionality.",
        "details": "1. Create RecipeForm component with validation\n2. Implement rich text editor for recipe instructions\n3. Add image upload and management functionality\n4. Create recipe preview functionality\n5. Implement save, publish, and delete operations\n6. Add form validation with error messages\n7. Create recipe status management (draft, published)\n8. Implement autosave functionality",
        "testStrategy": "1. Test form validation with valid and invalid data\n2. Verify image upload and management works correctly\n3. Test preview functionality matches actual display\n4. Verify CRUD operations work correctly\n5. Test autosave functionality\n6. Verify proper error handling and user feedback",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          4,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Bulk Import Functionality",
        "description": "Create a system for bulk importing recipes from JSON or CSV files with validation and error handling.",
        "details": "1. Create file upload component for JSON/CSV files\n2. Implement parsing logic for different file formats\n3. Add validation for imported recipe data\n4. Create preview functionality for imported recipes\n5. Implement batch processing with progress indicators\n6. Add error handling and reporting for invalid data\n7. Create conflict resolution for duplicate recipes\n8. Implement rollback functionality for failed imports",
        "testStrategy": "1. Test import with various file formats and sizes\n2. Verify validation correctly identifies invalid data\n3. Test preview functionality for imported recipes\n4. Verify error handling and reporting works correctly\n5. Test conflict resolution for duplicate recipes\n6. Verify performance with large import files",
        "priority": "low",
        "dependencies": [
          2,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement SEO Optimization with Structured Data",
        "description": "Add SEO features including structured data for recipes, meta tags, and sitemap generation.",
        "details": "1. Create structured data (JSON-LD) for recipes following schema.org\n2. Implement dynamic meta tags for recipe pages\n3. Add Open Graph and Twitter card metadata\n4. Create sitemap generation functionality\n5. Implement canonical URLs\n6. Add robots.txt configuration\n7. Create SEO-friendly URL structure\n8. Implement breadcrumbs with structured data",
        "testStrategy": "1. Validate structured data using Google's Structured Data Testing Tool\n2. Test meta tags on various platforms (Facebook, Twitter)\n3. Verify sitemap includes all necessary pages\n4. Test canonical URLs for duplicate content\n5. Verify robots.txt correctly configures crawling\n6. Test SEO score using Lighthouse",
        "priority": "medium",
        "dependencies": [
          3,
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Analytics Integration",
        "description": "Add analytics tracking for user behavior, page views, and interaction events.",
        "details": "1. Set up Google Analytics or similar service\n2. Create analytics provider component\n3. Implement page view tracking\n4. Add event tracking for user interactions\n5. Create custom dimensions for recipe categories\n6. Implement conversion tracking for important actions\n7. Add privacy-compliant consent management\n8. Create basic analytics dashboard or reporting",
        "testStrategy": "1. Verify page view tracking works correctly\n2. Test event tracking for various user interactions\n3. Verify custom dimensions are correctly populated\n4. Test consent management functionality\n5. Verify data appears correctly in analytics platform\n6. Test analytics with various user flows",
        "priority": "low",
        "dependencies": [
          5,
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement Internationalization (i18n) Support",
        "description": "Add support for multiple languages with translation files and language switching functionality.",
        "details": "1. Set up next-i18next or similar library\n2. Create translation files for supported languages\n3. Implement language detection and switching\n4. Add language-specific routing\n5. Create translated metadata for SEO\n6. Implement right-to-left (RTL) support for appropriate languages\n7. Add language preference persistence\n8. Create language switcher component",
        "testStrategy": "1. Test language switching functionality\n2. Verify translations appear correctly throughout the app\n3. Test RTL layout for appropriate languages\n4. Verify SEO metadata is correctly translated\n5. Test language preference persistence\n6. Verify performance impact of i18n implementation",
        "priority": "low",
        "dependencies": [
          3,
          5,
          6,
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement Performance Optimizations",
        "description": "Optimize the application for performance, including code splitting, lazy loading, and caching strategies.",
        "details": "1. Implement code splitting for route-based components\n2. Add lazy loading for non-critical components\n3. Optimize font loading with font-display\n4. Implement caching strategies for recipe data\n5. Add service worker for offline support\n6. Optimize critical rendering path\n7. Implement resource hints (preload, prefetch)\n8. Create performance monitoring and reporting",
        "testStrategy": "1. Measure performance metrics using Lighthouse\n2. Test load times across various network conditions\n3. Verify code splitting reduces initial bundle size\n4. Test offline functionality with service worker\n5. Measure Core Web Vitals (LCP, FID, CLS)\n6. Verify performance improvements with before/after benchmarks",
        "priority": "medium",
        "dependencies": [
          3,
          4,
          5,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Implement Accessibility Improvements",
        "description": "Enhance accessibility across the application, ensuring compliance with WCAG guidelines.",
        "details": "1. Perform accessibility audit using axe or similar tool\n2. Implement proper heading hierarchy\n3. Add ARIA attributes where necessary\n4. Ensure proper keyboard navigation\n5. Implement focus management\n6. Add skip links for keyboard users\n7. Ensure sufficient color contrast\n8. Create accessibility documentation",
        "testStrategy": "1. Test with screen readers (NVDA, VoiceOver)\n2. Verify keyboard navigation works throughout the app\n3. Test color contrast with various tools\n4. Perform automated accessibility testing\n5. Conduct manual testing with accessibility checklist\n6. Verify WCAG 2.1 AA compliance",
        "priority": "medium",
        "dependencies": [
          3,
          5,
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-01T04:56:48.940Z",
      "updated": "2025-08-01T05:38:19.168Z",
      "description": "Tasks for master context"
    }
  },
  "6-week-meal-plan": {
    "tasks": [
      {
        "id": 1,
        "title": "Core Dietary Approach System Architecture",
        "description": "Design and implement the core system architecture to support 7 dietary approaches (Keto, Sense, LCHF/Paleo, Anti-inflammatory, Mediterranean, Flexitarian, and 5:2) with TypeScript interfaces defining macro ratios, meal structures, and nutritional priorities.",
        "details": "## Implementation Details\n\n### 1. Project Setup\n- Initialize a TypeScript project with proper configuration\n- Set up ESLint and Prettier for code quality\n- Configure Jest for testing\n\n### 2. Core Interfaces\nCreate the following TypeScript interfaces:\n\n```typescript\n// Base dietary approach interface\ninterface DietaryApproach {\n  id: string;\n  name: string;\n  description: string;\n  macroRatios: MacroRatio;\n  mealStructure: MealStructure;\n  nutritionalPriorities: NutritionalPriority[];\n  restrictions: FoodRestriction[];\n  allowedFoods: FoodCategory[];\n}\n\n// Supporting interfaces\ninterface MacroRatio {\n  carbohydrates: Range; // percentage\n  protein: Range; // percentage\n  fat: Range; // percentage\n}\n\ninterface Range {\n  min: number;\n  target: number;\n  max: number;\n}\n\ninterface MealStructure {\n  mealsPerDay: number;\n  mealDistribution: MealDistribution[];\n  snacksAllowed: boolean;\n  fastingPeriods?: FastingPeriod[];\n}\n\ninterface MealDistribution {\n  mealType: MealType; // breakfast, lunch, dinner, snack\n  macroDistribution: MacroRatio;\n  portionSize: PortionSize;\n  timeOfDay?: TimeRange;\n}\n\nenum MealType {\n  Breakfast = 'breakfast',\n  Lunch = 'lunch',\n  Dinner = 'dinner',\n  Snack = 'snack'\n}\n\ninterface FastingPeriod {\n  daysPerWeek: number;\n  hoursPerDay?: number;\n  calorieReduction?: number; // percentage\n}\n\ninterface NutritionalPriority {\n  nutrient: string;\n  importance: number; // 1-10 scale\n  targetAmount?: string; // e.g., \"2000mg\"\n}\n\ninterface FoodRestriction {\n  category: string;\n  reason: string;\n  strictness: 'avoid' | 'limit' | 'eliminate';\n}\n\nenum FoodCategory {\n  Vegetables = 'vegetables',\n  Fruits = 'fruits',\n  Grains = 'grains',\n  Proteins = 'proteins',\n  Dairy = 'dairy',\n  Fats = 'fats',\n  // Add more as needed\n}\n\ninterface PortionSize {\n  unit: string;\n  amount: number;\n}\n\ninterface TimeRange {\n  start: string; // HH:MM format\n  end: string; // HH:MM format\n}\n```\n\n### 3. Implementation of Dietary Approaches\nCreate concrete implementations for each dietary approach:\n\n```typescript\n// Example implementation for Keto\nconst ketoDiet: DietaryApproach = {\n  id: 'keto',\n  name: 'Ketogenic Diet',\n  description: 'High-fat, adequate-protein, low-carbohydrate diet that forces the body to burn fats rather than carbohydrates.',\n  macroRatios: {\n    carbohydrates: { min: 5, target: 5, max: 10 },\n    protein: { min: 15, target: 20, max: 25 },\n    fat: { min: 70, target: 75, max: 80 }\n  },\n  mealStructure: {\n    mealsPerDay: 3,\n    mealDistribution: [\n      {\n        mealType: MealType.Breakfast,\n        macroDistribution: {\n          carbohydrates: { min: 5, target: 5, max: 10 },\n          protein: { min: 20, target: 25, max: 30 },\n          fat: { min: 65, target: 70, max: 75 }\n        },\n        portionSize: { unit: 'calories', amount: 500 }\n      },\n      // Add lunch and dinner distributions\n    ],\n    snacksAllowed: true\n  },\n  nutritionalPriorities: [\n    { nutrient: 'Omega-3 fatty acids', importance: 8 },\n    { nutrient: 'Electrolytes', importance: 9 },\n    { nutrient: 'Fiber', importance: 7 }\n  ],\n  restrictions: [\n    { category: 'Grains', reason: 'High carbohydrate content', strictness: 'eliminate' },\n    { category: 'Sugar', reason: 'Disrupts ketosis', strictness: 'eliminate' }\n  ],\n  allowedFoods: [\n    FoodCategory.Vegetables,\n    FoodCategory.Proteins,\n    FoodCategory.Fats\n  ]\n};\n\n// Implement similar structures for other dietary approaches\n```\n\n### 4. Factory Pattern for Diet Creation\nImplement a factory pattern to create and retrieve dietary approaches:\n\n```typescript\nclass DietaryApproachFactory {\n  private dietaryApproaches: Map<string, DietaryApproach> = new Map();\n\n  constructor() {\n    this.initializeDiets();\n  }\n\n  private initializeDiets(): void {\n    // Initialize all 7 dietary approaches\n    this.registerDiet(ketoDiet);\n    this.registerDiet(senseDiet);\n    // Register other diets...\n  }\n\n  private registerDiet(diet: DietaryApproach): void {\n    this.dietaryApproaches.set(diet.id, diet);\n  }\n\n  getDiet(id: string): DietaryApproach | undefined {\n    return this.dietaryApproaches.get(id);\n  }\n\n  getAllDiets(): DietaryApproach[] {\n    return Array.from(this.dietaryApproaches.values());\n  }\n}\n```\n\n### 5. Utility Functions\nCreate utility functions for dietary calculations:\n\n```typescript\nclass DietaryCalculator {\n  static calculateDailyCalories(weight: number, height: number, age: number, gender: 'male' | 'female', activityLevel: number): number {\n    // Implement BMR calculation using Harris-Benedict equation\n    // Apply activity factor\n    return 0; // Placeholder\n  }\n\n  static calculateMacroGrams(calories: number, macroRatio: MacroRatio): {carbs: number, protein: number, fat: number} {\n    // Convert percentage to grams based on calories\n    // Carbs & protein = 4 calories per gram, fat = 9 calories per gram\n    return {carbs: 0, protein: 0, fat: 0}; // Placeholder\n  }\n}\n```\n\n### 6. Documentation\n- Create comprehensive documentation for each dietary approach\n- Document the reasoning behind macro ratios and meal structures\n- Provide usage examples for the system\n\n### 7. Architecture Considerations\n- Ensure the system is extensible to add new dietary approaches in the future\n- Design for compatibility with meal planning and recipe recommendation systems\n- Implement proper error handling and validation\n- Consider internationalization for food categories and measurements",
        "testStrategy": "## Test Strategy\n\n### 1. Unit Tests\n- **Interface Validation Tests**: Verify that all dietary approach implementations conform to the required interfaces.\n  ```typescript\n  test('Keto diet implements DietaryApproach interface correctly', () => {\n    expect(ketoDiet).toHaveProperty('id');\n    expect(ketoDiet).toHaveProperty('macroRatios');\n    // Test all required properties\n  });\n  ```\n\n- **Macro Ratio Tests**: Ensure macro ratios for each diet sum to approximately 100%.\n  ```typescript\n  test('Macro ratios sum to approximately 100%', () => {\n    const diets = new DietaryApproachFactory().getAllDiets();\n    diets.forEach(diet => {\n      const target = diet.macroRatios.carbohydrates.target + \n                    diet.macroRatios.protein.target + \n                    diet.macroRatios.fat.target;\n      expect(target).toBeGreaterThanOrEqual(98);\n      expect(target).toBeLessThanOrEqual(102);\n    });\n  });\n  ```\n\n- **Utility Function Tests**: Test all calculator functions with known inputs and expected outputs.\n  ```typescript\n  test('Calorie calculator returns expected values', () => {\n    const calories = DietaryCalculator.calculateDailyCalories(70, 175, 30, 'male', 1.5);\n    expect(calories).toBeCloseTo(2500, -2); // Within 100 calories\n  });\n  ```\n\n### 2. Integration Tests\n- **Factory Pattern Tests**: Verify the factory correctly initializes and returns all dietary approaches.\n  ```typescript\n  test('Factory returns all 7 dietary approaches', () => {\n    const factory = new DietaryApproachFactory();\n    expect(factory.getAllDiets().length).toBe(7);\n  });\n  ```\n\n- **Diet Retrieval Tests**: Test that specific diets can be retrieved by ID.\n  ```typescript\n  test('Can retrieve specific diet by ID', () => {\n    const factory = new DietaryApproachFactory();\n    const keto = factory.getDiet('keto');\n    expect(keto?.name).toBe('Ketogenic Diet');\n  });\n  ```\n\n### 3. Validation Tests\n- **Nutritional Consistency**: Verify that nutritional priorities align with the dietary philosophy.\n  ```typescript\n  test('Keto diet prioritizes appropriate nutrients', () => {\n    const keto = new DietaryApproachFactory().getDiet('keto');\n    const priorities = keto?.nutritionalPriorities.map(p => p.nutrient);\n    expect(priorities).toContain('Electrolytes');\n    expect(priorities).toContain('Omega-3 fatty acids');\n  });\n  ```\n\n- **Food Restriction Validation**: Ensure food restrictions are appropriate for each diet.\n  ```typescript\n  test('Keto diet restricts high-carb foods', () => {\n    const keto = new DietaryApproachFactory().getDiet('keto');\n    const restrictions = keto?.restrictions.map(r => r.category);\n    expect(restrictions).toContain('Grains');\n    expect(restrictions).toContain('Sugar');\n  });\n  ```\n\n### 4. Documentation Tests\n- Verify that all public interfaces and classes are properly documented with JSDoc comments.\n- Use a documentation coverage tool to ensure comprehensive documentation.\n\n### 5. Manual Testing\n- Create a simple UI to display each dietary approach's details.\n- Manually verify that the information for each diet is accurate according to nutritional science.\n- Have a nutritionist or domain expert review the dietary specifications for accuracy.\n\n### 6. Performance Testing\n- Test the system with a large number of concurrent requests to ensure scalability.\n- Measure memory usage when loading all dietary approaches simultaneously.\n\n### 7. Acceptance Criteria\n- All 7 dietary approaches are properly implemented with correct macro ratios.\n- Each approach has well-defined meal structures and nutritional priorities.\n- The factory pattern successfully manages all dietary approaches.\n- All tests pass with at least 90% code coverage.\n- Documentation is complete and accurate.",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Project Setup and Core Interface Definition",
            "description": "Initialize the TypeScript project with proper configuration and define all core interfaces for the dietary approach system.",
            "dependencies": [],
            "details": "Set up TypeScript project with ESLint, Prettier, and Jest configurations. Create the base DietaryApproach interface and all supporting interfaces including MacroRatio, Range, MealStructure, MealDistribution, and related enums. Ensure proper type definitions for all components of the dietary system.",
            "status": "done",
            "testStrategy": "Write unit tests to verify interface structure and type safety. Test type compatibility between interfaces and ensure proper constraints on enum values."
          },
          {
            "id": 2,
            "title": "Implement Concrete Dietary Approach Models",
            "description": "Create concrete implementations for all 7 dietary approaches with accurate macro ratios, meal structures, and nutritional priorities.",
            "dependencies": [],
            "details": "Implement detailed models for Keto, Sense, LCHF/Paleo, Anti-inflammatory, Mediterranean, Flexitarian, and 5:2 dietary approaches. Each implementation should include specific macronutrient ratios, meal structures, nutritional priorities, food restrictions, and allowed food categories based on scientific research.",
            "status": "pending",
            "testStrategy": "Test each dietary approach implementation against the DietaryApproach interface. Verify that macro ratios sum to 100%, meal structures are valid, and all required properties are properly defined."
          },
          {
            "id": 3,
            "title": "Develop Factory Pattern for Diet Creation",
            "description": "Implement a factory pattern to create, retrieve, and manage dietary approach instances.",
            "dependencies": [],
            "details": "Create a DietaryApproachFactory class that initializes and stores all dietary approach implementations. Implement methods to register new diets, retrieve diets by ID, and get all available diets. Ensure the factory is implemented as a singleton or injectable service.",
            "status": "pending",
            "testStrategy": "Test the factory's ability to correctly register and retrieve dietary approaches. Verify that all 7 diets are properly initialized and accessible through the factory methods."
          },
          {
            "id": 4,
            "title": "Create Dietary Calculation Utilities",
            "description": "Develop utility functions for dietary calculations including calorie needs, macro conversions, and nutritional analysis.",
            "dependencies": [],
            "details": "Implement a DietaryCalculator class with static methods for calculating daily calorie needs based on user metrics, converting macro percentages to gram amounts, and analyzing nutritional adequacy of meal plans. Include functions for BMR calculation using established formulas and activity factor adjustments.",
            "status": "pending",
            "testStrategy": "Test calculation accuracy against known values for various user profiles. Verify that macro gram calculations correctly convert percentages based on calorie targets. Test edge cases like very low or high calorie diets."
          },
          {
            "id": 5,
            "title": "Documentation and Architecture Finalization",
            "description": "Create comprehensive documentation and finalize the system architecture with extensibility considerations.",
            "dependencies": [],
            "details": "Document each dietary approach with scientific rationale for macro ratios and meal structures. Create usage examples and API documentation. Ensure the architecture supports future dietary approaches, internationalization, and integration with meal planning systems. Implement proper error handling, validation, and logging throughout the system.",
            "status": "pending",
            "testStrategy": "Perform integration tests to verify the complete system works as expected. Test the extensibility by adding a mock new dietary approach. Verify documentation accuracy and completeness through peer review."
          }
        ]
      },
      {
        "id": 2,
        "title": "Ingredient Tagging and Filtering System",
        "description": "Develop a system for tagging ingredients with categories and exclusions, with automatic recipe filtering based on exclusions and an admin interface for tag management and bulk recipe import.",
        "details": "## Implementation Details\n\n### 1. Data Model Design\n- Create TypeScript interfaces for ingredients and tags:\n```typescript\ninterface Ingredient {\n  id: string;\n  name: string;\n  categories: IngredientCategory[];\n  exclusions: DietaryExclusion[];\n}\n\nenum IngredientCategory {\n  PROTEIN = 'protein',\n  VEGETABLE = 'vegetable',\n  DAIRY = 'dairy',\n  GRAIN = 'grain',\n  SPICE = 'spice',\n  // Additional categories as needed\n}\n\nenum DietaryExclusion {\n  PORK = 'pork',\n  DAIRY = 'dairy',\n  NUTS = 'nuts',\n  GLUTEN = 'gluten',\n  SHELLFISH = 'shellfish',\n  // Additional exclusions as needed\n}\n\ninterface Recipe {\n  id: string;\n  name: string;\n  ingredients: Ingredient[];\n  // Other recipe properties\n}\n\ninterface UserPreferences {\n  dietaryExclusions: DietaryExclusion[];\n  // Other user preferences\n}\n```\n\n### 2. Database Schema\n- Design database schema for ingredients, tags, and their relationships\n- Create migrations for the new tables\n- Implement indexes for efficient querying\n\n### 3. Ingredient Tagging Service\n- Create a service to manage ingredient tags:\n```typescript\nclass IngredientTaggingService {\n  async tagIngredient(ingredientId: string, categories: IngredientCategory[], exclusions: DietaryExclusion[]): Promise<Ingredient>;\n  async getIngredientsByCategory(category: IngredientCategory): Promise<Ingredient[]>;\n  async getIngredientsByExclusion(exclusion: DietaryExclusion): Promise<Ingredient[]>;\n}\n```\n\n### 4. Recipe Filtering System\n- Implement a filtering service that excludes recipes based on user preferences:\n```typescript\nclass RecipeFilterService {\n  async filterRecipesByExclusions(recipes: Recipe[], exclusions: DietaryExclusion[]): Promise<Recipe[]> {\n    return recipes.filter(recipe => \n      !recipe.ingredients.some(ingredient => \n        ingredient.exclusions.some(exclusion => \n          exclusions.includes(exclusion)\n        )\n      )\n    );\n  }\n}\n```\n\n### 5. Admin Interface\n- Create RESTful API endpoints for tag management:\n  - GET /api/ingredients\n  - GET /api/ingredients/:id\n  - POST /api/ingredients\n  - PUT /api/ingredients/:id\n  - GET /api/categories\n  - GET /api/exclusions\n- Develop admin UI components:\n  - Ingredient list view with filtering and sorting\n  - Ingredient detail view with tag management\n  - Bulk tagging interface for multiple ingredients\n  - Tag management interface for adding/editing categories and exclusions\n\n### 6. Bulk Import System\n- Design and implement a CSV/JSON import format for recipes and ingredients\n- Create a parser for the import format:\n```typescript\ninterface ImportResult {\n  success: boolean;\n  importedCount: number;\n  errors: ImportError[];\n}\n\nclass RecipeImportService {\n  async importRecipesFromCSV(fileContent: string): Promise<ImportResult>;\n  async importRecipesFromJSON(jsonData: any): Promise<ImportResult>;\n}\n```\n- Implement validation for imported data\n- Create a background job system for processing large imports\n\n### 7. Integration with Dietary Approaches\n- Ensure the tagging system integrates with the dietary approach system from Task #1\n- Map exclusions to dietary approaches where applicable\n\n### 8. Performance Considerations\n- Implement caching for frequently accessed tag data\n- Optimize database queries for ingredient filtering\n- Consider using database materialized views for common filtering scenarios",
        "testStrategy": "## Test Strategy\n\n### 1. Unit Tests\n- Test ingredient tagging service:\n```typescript\ndescribe('IngredientTaggingService', () => {\n  test('should correctly tag an ingredient with categories', async () => {\n    const service = new IngredientTaggingService();\n    const ingredient = await service.tagIngredient('123', [IngredientCategory.PROTEIN], []);\n    expect(ingredient.categories).toContain(IngredientCategory.PROTEIN);\n  });\n\n  test('should correctly tag an ingredient with exclusions', async () => {\n    const service = new IngredientTaggingService();\n    const ingredient = await service.tagIngredient('123', [], [DietaryExclusion.NUTS]);\n    expect(ingredient.exclusions).toContain(DietaryExclusion.NUTS);\n  });\n});\n```\n\n- Test recipe filtering service:\n```typescript\ndescribe('RecipeFilterService', () => {\n  test('should filter out recipes containing excluded ingredients', async () => {\n    const service = new RecipeFilterService();\n    const recipes = [/* mock recipes */];\n    const filteredRecipes = await service.filterRecipesByExclusions(recipes, [DietaryExclusion.DAIRY]);\n    \n    // Verify no filtered recipes contain dairy\n    filteredRecipes.forEach(recipe => {\n      recipe.ingredients.forEach(ingredient => {\n        expect(ingredient.exclusions).not.toContain(DietaryExclusion.DAIRY);\n      });\n    });\n  });\n});\n```\n\n### 2. Integration Tests\n- Test API endpoints for ingredient tag management\n- Test bulk import functionality with various file formats and sizes\n- Verify database constraints and relationships\n\n### 3. Performance Tests\n- Benchmark filtering performance with large recipe datasets\n- Test bulk import performance with 1000+ recipes\n- Verify caching mechanisms are working correctly\n\n### 4. User Acceptance Tests\n- Verify admin interface functionality:\n  - Create a new ingredient with tags\n  - Edit existing ingredient tags\n  - Bulk tag multiple ingredients\n  - Import recipes from CSV/JSON\n- Test recipe filtering from user perspective:\n  - Set dietary exclusions in user preferences\n  - Verify recipes with excluded ingredients are not shown\n\n### 5. Regression Tests\n- Ensure integration with dietary approach system works correctly\n- Verify existing recipe functionality is not broken\n\n### 6. Edge Cases\n- Test with ingredients having multiple exclusions\n- Test with empty tag sets\n- Test with malformed import data\n- Test with extremely large datasets",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Data Model and Database Schema Implementation",
            "description": "Design and implement the TypeScript interfaces and database schema for ingredients, tags, categories, and exclusions.",
            "dependencies": [],
            "details": "Create TypeScript interfaces for Ingredient, IngredientCategory, DietaryExclusion, Recipe, and UserPreferences. Design the database schema with appropriate tables and relationships. Implement database migrations with proper indexes for efficient querying. Ensure the data model supports the requirements for ingredient categorization and dietary exclusions.",
            "status": "done",
            "testStrategy": "Write unit tests to validate the data model interfaces. Create database schema validation tests to ensure proper constraints and relationships. Test migration scripts in a development environment before deployment."
          },
          {
            "id": 2,
            "title": "Ingredient Tagging Service Development",
            "description": "Create a service to manage ingredient tags, categories, and exclusions with CRUD operations.",
            "dependencies": [
              "2.1"
            ],
            "details": "Implement the IngredientTaggingService with methods for tagging ingredients with categories and exclusions. Develop functions to retrieve ingredients by category or exclusion type. Create data access methods for efficient database operations. Implement validation logic to ensure data integrity when tagging ingredients.",
            "status": "pending",
            "testStrategy": "Write unit tests for all service methods, including edge cases. Test database interactions with a test database. Verify that tagging operations correctly update the database and return expected results."
          },
          {
            "id": 3,
            "title": "Recipe Filtering System Implementation",
            "description": "Develop a filtering system that excludes recipes based on user dietary preferences and exclusions.",
            "dependencies": [
              "2.1",
              "2.2"
            ],
            "details": "Implement the RecipeFilterService with methods to filter recipes based on user dietary exclusions. Create efficient algorithms to match recipe ingredients against user exclusions. Develop caching strategies for frequently accessed filtering results. Ensure the filtering system integrates with the dietary approach system from Task #1.",
            "status": "pending",
            "testStrategy": "Create comprehensive unit tests for filtering logic with various exclusion scenarios. Benchmark performance for large recipe datasets. Test integration with the dietary approach system to ensure compatibility."
          },
          {
            "id": 4,
            "title": "Admin Interface for Tag Management",
            "description": "Build RESTful API endpoints and admin UI components for ingredient and tag management.",
            "dependencies": [
              "2.1",
              "2.2",
              "2.3"
            ],
            "details": "Develop RESTful API endpoints for ingredient and tag management (GET, POST, PUT operations). Create admin UI components including ingredient list view, detail view, and tag management interfaces. Implement filtering, sorting, and pagination for the ingredient list. Design and build the tag management interface for adding/editing categories and exclusions.",
            "status": "pending",
            "testStrategy": "Test API endpoints with integration tests. Verify UI components with unit tests and user interface testing. Ensure proper error handling and validation for all API operations."
          },
          {
            "id": 5,
            "title": "Bulk Import System for Recipes and Ingredients",
            "description": "Create a system for importing recipes and ingredients in bulk via CSV/JSON formats.",
            "dependencies": [
              "2.1",
              "2.2",
              "2.4"
            ],
            "details": "Design and implement CSV/JSON import formats for recipes and ingredients. Create the RecipeImportService with methods for importing from different file formats. Implement validation for imported data to ensure integrity. Develop a background job system for processing large imports. Create error handling and reporting for failed imports.",
            "status": "pending",
            "testStrategy": "Test import functionality with various valid and invalid data files. Verify error handling and validation logic. Test performance with large import files. Ensure the background job system correctly processes imports asynchronously."
          }
        ]
      },
      {
        "id": 3,
        "title": "User Wizard Flow for 6-Week Meal Plan System",
        "description": "Develop an interactive, multi-step wizard interface that guides users through the process of creating a personalized 6-week meal plan, collecting necessary information about their profile, goals, and preferences.",
        "details": "## Implementation Details\n\n### 1. Wizard Architecture\n- Implement a modular, state-based wizard component using React and TypeScript\n- Create a WizardContext to manage state across steps\n- Implement navigation controls (previous, next, save & exit)\n- Add progress indicator showing completion percentage\n\n```typescript\n// Wizard context type definition\ninterface WizardContextType {\n  currentStep: number;\n  wizardData: UserProfileData;\n  updateWizardData: (data: Partial<UserProfileData>) => void;\n  nextStep: () => void;\n  prevStep: () => void;\n  goToStep: (step: number) => void;\n  saveProgress: () => Promise<void>;\n}\n\n// Main wizard component structure\nconst MealPlanWizard: React.FC = () => {\n  const [currentStep, setCurrentStep] = useState(0);\n  const [wizardData, setWizardData] = useState<UserProfileData>({});\n  \n  // Step components\n  const steps = [\n    <BasicProfileStep />,\n    <GoalSettingStep />,\n    <EnergyBalanceStep />,\n    <DietaryApproachStep />,\n    <FoodPreferencesStep />,\n    <NutritionalAssessmentStep />,\n    <PlanReviewStep />\n  ];\n  \n  return (\n    <WizardContext.Provider value={...}>\n      <WizardProgressBar currentStep={currentStep} totalSteps={steps.length} />\n      {steps[currentStep]}\n      <WizardNavigation />\n    </WizardContext.Provider>\n  );\n};\n```\n\n### 2. Step 1: Basic Profile Collection\n- Create form components for collecting:\n  - Gender (radio buttons)\n  - Age (number input with validation)\n  - Height (with unit selection)\n  - Weight (with unit selection)\n  - Activity level (dropdown with 5 options from sedentary to very active)\n- Implement real-time validation with helpful error messages\n- Add tooltips explaining how activity level affects calculations\n\n### 3. Step 2: Goal Setting\n- Implement goal selection interface (weight loss, maintenance, muscle gain)\n- For weight loss/gain goals, add target weight and timeframe inputs\n- Include realistic goal setting guidance (e.g., 0.5-1kg per week for weight loss)\n- Add visual feedback showing goal difficulty based on selections\n\n### 4. Step 3: Energy Balance Calculation\n- Implement BMR calculation using the Mifflin-St Jeor equation\n- Calculate TDEE based on activity level\n- Determine appropriate calorie targets based on goals\n- Display visual breakdown of calculations with explanations\n- Allow manual adjustment of calculated values with reasonable constraints\n\n```typescript\n// Energy calculation service\nclass EnergyCalculationService {\n  calculateBMR(gender: 'male' | 'female', weight: number, height: number, age: number): number {\n    if (gender === 'male') {\n      return 10 * weight + 6.25 * height - 5 * age + 5;\n    } else {\n      return 10 * weight + 6.25 * height - 5 * age - 161;\n    }\n  }\n  \n  calculateTDEE(bmr: number, activityLevel: ActivityLevel): number {\n    const activityMultipliers = {\n      [ActivityLevel.SEDENTARY]: 1.2,\n      [ActivityLevel.LIGHTLY_ACTIVE]: 1.375,\n      [ActivityLevel.MODERATELY_ACTIVE]: 1.55,\n      [ActivityLevel.VERY_ACTIVE]: 1.725,\n      [ActivityLevel.EXTRA_ACTIVE]: 1.9\n    };\n    \n    return bmr * activityMultipliers[activityLevel];\n  }\n  \n  calculateCalorieTarget(tdee: number, goal: UserGoal, targetWeeklyChange?: number): number {\n    // Implementation for calculating target calories based on goal\n  }\n}\n```\n\n### 5. Step 4: Dietary Approach Selection\n- Create an interactive selection interface for the 7 dietary approaches\n- Include visual cards with brief descriptions of each approach\n- Implement a comparison feature to help users understand differences\n- Add a \"recommended\" tag based on user's profile and goals\n- Connect with the Core Dietary Approach System (Task #1)\n\n### 6. Step 5: Food Preferences and Restrictions\n- Implement searchable ingredient selection interface\n- Create category-based browsing of common ingredients\n- Add quick-select buttons for common allergies and restrictions\n- Integrate with the Ingredient Tagging System (Task #2)\n- Include preference strength indicators (dislike, neutral, like, love)\n\n### 7. Step 6: Nutritional Deficiency Assessment\n- Create a questionnaire to identify potential nutritional deficiencies\n- Implement scoring algorithm based on responses and previous selections\n- Generate visual report of potential deficiency risks\n- Provide educational content about addressing deficiencies\n\n### 8. Step 7: Plan Generation and Review\n- Display generated meal plan summary with macronutrient breakdown\n- Show sample meals from the plan\n- Implement customization options (regenerate specific days/meals)\n- Add save, print, and export functionality\n- Include educational content about the selected approach\n\n### 9. Personalization Features\n- Implement personalized messaging throughout the wizard\n- Add adaptive question flow based on previous answers\n- Include encouraging feedback at each step completion\n- Use the user's name throughout the process\n- Add subtle animations and transitions between steps\n- Implement a conversational tone in all copy\n\n### 10. Data Persistence\n- Save progress automatically between steps\n- Implement local storage backup in case of connection issues\n- Create user profile data structure that can be efficiently stored and retrieved\n\n### 11. Mobile Responsiveness\n- Ensure all wizard steps work well on mobile devices\n- Implement touch-friendly UI elements\n- Test on various screen sizes and orientations",
        "testStrategy": "## Test Strategy\n\n### 1. Unit Tests\n- Test each wizard step component in isolation:\n```typescript\ndescribe('BasicProfileStep', () => {\n  test('validates required fields correctly', () => {\n    render(<BasicProfileStep />);\n    fireEvent.click(screen.getByText('Next'));\n    expect(screen.getByText('Age is required')).toBeInTheDocument();\n  });\n  \n  test('calculates BMI correctly', () => {\n    render(<BasicProfileStep />);\n    fireEvent.change(screen.getByLabelText('Height (cm)'), { target: { value: '180' } });\n    fireEvent.change(screen.getByLabelText('Weight (kg)'), { target: { value: '80' } });\n    expect(screen.getByText('BMI: 24.7')).toBeInTheDocument();\n  });\n});\n```\n\n- Test energy calculation functions:\n```typescript\ndescribe('EnergyCalculationService', () => {\n  const service = new EnergyCalculationService();\n  \n  test('calculates BMR correctly for males', () => {\n    const bmr = service.calculateBMR('male', 80, 180, 30);\n    expect(bmr).toBeCloseTo(1805, 0);\n  });\n  \n  test('calculates TDEE correctly based on activity level', () => {\n    const bmr = 1800;\n    const tdee = service.calculateTDEE(bmr, ActivityLevel.MODERATELY_ACTIVE);\n    expect(tdee).toBeCloseTo(2790, 0);\n  });\n});\n```\n\n### 2. Integration Tests\n- Test wizard navigation flow:\n```typescript\ndescribe('MealPlanWizard Navigation', () => {\n  test('navigates forward and backward correctly', async () => {\n    render(<MealPlanWizard />);\n    \n    // Fill out first step\n    fireEvent.change(screen.getByLabelText('Age'), { target: { value: '30' } });\n    // Fill other required fields...\n    \n    fireEvent.click(screen.getByText('Next'));\n    expect(screen.getByText('What is your goal?')).toBeInTheDocument();\n    \n    fireEvent.click(screen.getByText('Previous'));\n    expect(screen.getByLabelText('Age')).toHaveValue('30');\n  });\n});\n```\n\n- Test data persistence between steps:\n```typescript\ndescribe('WizardContext', () => {\n  test('maintains data between steps', async () => {\n    render(<MealPlanWizard />);\n    \n    // Fill profile data\n    fireEvent.change(screen.getByLabelText('Age'), { target: { value: '30' } });\n    fireEvent.click(screen.getByText('Next'));\n    \n    // Navigate back\n    fireEvent.click(screen.getByText('Previous'));\n    \n    // Check data was preserved\n    expect(screen.getByLabelText('Age')).toHaveValue('30');\n  });\n});\n```\n\n### 3. End-to-End Tests\n- Test complete wizard flow with Cypress:\n```javascript\ndescribe('Meal Plan Wizard E2E', () => {\n  it('completes full wizard flow and generates plan', () => {\n    cy.visit('/meal-plan-wizard');\n    \n    // Step 1: Basic Profile\n    cy.get('[data-testid=\"gender-male\"]').click();\n    cy.get('[data-testid=\"age-input\"]').type('35');\n    cy.get('[data-testid=\"height-input\"]').type('175');\n    cy.get('[data-testid=\"weight-input\"]').type('75');\n    cy.get('[data-testid=\"activity-level\"]').select('Moderately Active');\n    cy.get('[data-testid=\"next-button\"]').click();\n    \n    // Continue through all steps...\n    \n    // Verify plan generation\n    cy.get('[data-testid=\"meal-plan-summary\"]').should('be.visible');\n    cy.get('[data-testid=\"calorie-target\"]').should('contain', '2000');\n  });\n});\n```\n\n### 4. Usability Testing\n- Conduct moderated usability sessions with 5-7 participants\n- Create specific tasks for participants to complete\n- Measure:\n  - Task completion rate\n  - Time on task\n  - Error rate\n  - Subjective satisfaction (SUS questionnaire)\n- Focus on identifying friction points in the wizard flow\n\n### 5. Accessibility Testing\n- Verify WCAG 2.1 AA compliance for all wizard components\n- Test keyboard navigation through the entire wizard\n- Verify screen reader compatibility\n- Check color contrast ratios meet accessibility standards\n- Test with various font sizes and zoom levels\n\n### 6. Cross-Browser and Device Testing\n- Test on major browsers (Chrome, Firefox, Safari, Edge)\n- Test on various device sizes:\n  - Mobile phones (iPhone, Android)\n  - Tablets (iPad, Android tablets)\n  - Desktop (various window sizes)\n- Verify responsive behavior and touch interactions\n\n### 7. Performance Testing\n- Measure and optimize load time for each wizard step\n- Test with simulated slow network connections\n- Verify wizard performs well with large datasets (many food preferences)\n- Test save/load functionality with various connection states",
        "status": "pending",
        "dependencies": [
          1,
          2
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Wizard Architecture and Navigation",
            "description": "Create the core wizard component structure with state management, navigation controls, and progress indicators using React and TypeScript.",
            "dependencies": [],
            "details": "Develop a modular, state-based wizard component using React and TypeScript. Implement WizardContext to manage state across steps, including user data and navigation state. Create navigation controls (previous, next, save & exit buttons) with proper validation. Add a visual progress indicator showing completion percentage. Ensure the wizard maintains state between steps and handles browser navigation gracefully.",
            "status": "done",
            "testStrategy": "Write unit tests for the wizard context to verify state updates work correctly. Test navigation controls to ensure they update the current step appropriately. Create integration tests to verify the wizard maintains state between steps. Test the progress indicator to ensure it accurately reflects completion status."
          },
          {
            "id": 2,
            "title": "Develop User Profile Collection Steps",
            "description": "Implement the first three wizard steps for collecting basic user information, goals, and calculating energy requirements.",
            "dependencies": [
              "3.1"
            ],
            "details": "Create form components for Step 1 (Basic Profile) to collect gender, age, height, weight, and activity level with appropriate validation. Implement Step 2 (Goal Setting) with goal selection interface and realistic guidance. Develop Step 3 (Energy Balance) to calculate BMR using the Mifflin-St Jeor equation, TDEE based on activity level, and determine appropriate calorie targets with visual explanations.",
            "status": "pending",
            "testStrategy": "Test form validation for each input field to ensure proper error handling. Verify BMR and TDEE calculations match expected results for various user profiles. Test goal setting logic to ensure it provides appropriate recommendations based on user inputs."
          },
          {
            "id": 3,
            "title": "Implement Dietary Preferences Collection",
            "description": "Create wizard steps for dietary approach selection and food preferences/restrictions collection.",
            "dependencies": [
              "3.1",
              "3.2"
            ],
            "details": "Develop Step 4 (Dietary Approach Selection) with interactive cards for the 7 dietary approaches, including descriptions and comparison features. Implement Step 5 (Food Preferences) with searchable ingredient selection, category-based browsing, and quick-select buttons for common allergies. Integrate with the Ingredient Tagging System (Task #2) to properly categorize and filter ingredients based on user selections.",
            "status": "pending",
            "testStrategy": "Test the dietary approach selection interface to ensure it correctly captures user choices. Verify the food preferences interface properly handles ingredient searches and selections. Test integration with the Ingredient Tagging System to confirm proper filtering based on user restrictions."
          },
          {
            "id": 4,
            "title": "Create Nutritional Assessment and Plan Review Steps",
            "description": "Implement the final wizard steps for nutritional deficiency assessment and meal plan review/customization.",
            "dependencies": [
              "3.1",
              "3.2",
              "3.3"
            ],
            "details": "Develop Step 6 (Nutritional Deficiency Assessment) with a questionnaire to identify potential nutritional deficiencies and generate visual reports. Create Step 7 (Plan Generation and Review) to display the generated meal plan summary with macronutrient breakdown, sample meals, and customization options. Implement save, print, and export functionality for the final plan.",
            "status": "pending",
            "testStrategy": "Test the nutritional assessment algorithm to verify it correctly identifies potential deficiencies based on user inputs. Verify the plan review interface displays accurate information and properly handles customization requests. Test export functionality to ensure it generates correct outputs in all supported formats."
          },
          {
            "id": 5,
            "title": "Implement Data Persistence and Mobile Responsiveness",
            "description": "Develop data persistence mechanisms and ensure the wizard interface is fully responsive across all device types.",
            "dependencies": [
              "3.1",
              "3.2",
              "3.3",
              "3.4"
            ],
            "details": "Implement automatic progress saving between steps using both API calls and local storage backup. Create a robust user profile data structure that can be efficiently stored and retrieved. Ensure all wizard steps work well on mobile devices with touch-friendly UI elements. Test the interface on various screen sizes and orientations to guarantee a consistent user experience. Add personalized messaging and adaptive question flow based on previous answers.",
            "status": "pending",
            "testStrategy": "Test data persistence by simulating network failures to verify local storage backup works correctly. Verify saved data is properly restored when users return to the wizard. Test the interface on multiple device sizes and orientations to ensure responsive design works as expected. Verify touch interactions work properly on mobile devices."
          }
        ]
      },
      {
        "id": 4,
        "title": "Meal Plan Generation Algorithm",
        "description": "Create an algorithm that generates personalized 6-week meal plans based on user inputs including profile, goals, dietary approach, and restrictions, with support for all 7 dietary approaches and special handling for the 5:2 diet.",
        "details": "## Implementation Details\n\n### 1. Algorithm Architecture\n- Implement a modular, service-based architecture for the meal plan generation system\n- Create a core `MealPlanGenerator` class that orchestrates the generation process\n- Develop specialized services for each component of the algorithm\n\n```typescript\n// Core generator class\nclass MealPlanGenerator {\n  constructor(\n    private macroCalculator: MacroCalculatorService,\n    private recipeFilterService: RecipeFilterService,\n    private mealDistributionService: MealDistributionService,\n    private shoppingListGenerator: ShoppingListService\n  ) {}\n\n  async generateMealPlan(userProfile: UserProfile): Promise<MealPlan> {\n    // Implementation steps\n  }\n}\n```\n\n### 2. Macro Calculation Service\n- Implement the `MacroCalculatorService` to determine daily caloric and macronutrient needs\n- Support different calculation methods based on dietary approach\n- Handle special cases for 5:2 diet (500 calorie days)\n\n```typescript\nclass MacroCalculatorService {\n  calculateDailyMacros(\n    profile: UserProfile, \n    dietaryApproach: DietaryApproach,\n    isFastDay: boolean = false\n  ): DailyMacros {\n    // Calculate BMR using Mifflin-St Jeor equation\n    const bmr = this.calculateBMR(profile.weight, profile.height, profile.age, profile.gender);\n    \n    // Apply activity multiplier\n    let tdee = bmr * this.getActivityMultiplier(profile.activityLevel);\n    \n    // Apply goal adjustment (weight loss, maintenance, gain)\n    const adjustedCalories = this.applyGoalAdjustment(tdee, profile.goal);\n    \n    // Handle 5:2 diet fast days\n    if (dietaryApproach.id === '5:2' && isFastDay) {\n      return this.calculateFastDayMacros();\n    }\n    \n    // Calculate macros based on dietary approach ratios\n    return this.calculateMacrosFromCalories(adjustedCalories, dietaryApproach.macroRatios);\n  }\n  \n  private calculateFastDayMacros(): DailyMacros {\n    // Return 500 calorie day macros\n    return {\n      calories: 500,\n      protein: 50, // grams\n      carbs: 30,   // grams\n      fat: 15      // grams\n    };\n  }\n}\n```\n\n### 3. Recipe Filtering Service\n- Develop the `RecipeFilterService` to filter recipes based on:\n  - Dietary approach compatibility\n  - User exclusions and allergies\n  - Macro requirements\n  - Meal type (breakfast, lunch, dinner, snack)\n\n```typescript\nclass RecipeFilterService {\n  filterRecipes(\n    recipeDatabase: Recipe[],\n    dietaryApproach: DietaryApproach,\n    userExclusions: string[],\n    mealType: MealType,\n    targetMacros: MacroRange\n  ): Recipe[] {\n    return recipeDatabase.filter(recipe => {\n      // Check if recipe matches dietary approach\n      if (!this.matchesDietaryApproach(recipe, dietaryApproach)) {\n        return false;\n      }\n      \n      // Check if recipe contains excluded ingredients\n      if (this.containsExclusions(recipe, userExclusions)) {\n        return false;\n      }\n      \n      // Check if recipe is appropriate for meal type\n      if (!this.matchesMealType(recipe, mealType)) {\n        return false;\n      }\n      \n      // Check if recipe macros are within target range\n      if (!this.macrosInRange(recipe, targetMacros)) {\n        return false;\n      }\n      \n      return true;\n    });\n  }\n}\n```\n\n### 4. Meal Distribution Service\n- Create the `MealDistributionService` to distribute daily calories across meals\n- Support different meal structures based on dietary approach\n- Implement logic to balance macros across the day\n\n```typescript\nclass MealDistributionService {\n  distributeMeals(\n    dailyMacros: DailyMacros,\n    mealStructure: MealStructure\n  ): MealMacroDistribution[] {\n    const meals: MealMacroDistribution[] = [];\n    \n    // Distribute calories and macros according to meal structure percentages\n    for (const meal of mealStructure.meals) {\n      meals.push({\n        mealType: meal.type,\n        targetMacros: {\n          calories: dailyMacros.calories * meal.caloriePercentage,\n          protein: dailyMacros.protein * meal.macroDistribution.protein,\n          carbs: dailyMacros.carbs * meal.macroDistribution.carbs,\n          fat: dailyMacros.fat * meal.macroDistribution.fat\n        }\n      });\n    }\n    \n    return meals;\n  }\n}\n```\n\n### 5. Meal Plan Assembly\n- Implement logic to assemble the 6-week meal plan\n- Create variation patterns to avoid repetition\n- Handle special cases for 5:2 diet (alternating normal and fast days)\n\n```typescript\nclass MealPlanAssembler {\n  assembleMealPlan(\n    userProfile: UserProfile,\n    dietaryApproach: DietaryApproach,\n    filteredRecipesByMealType: Map<MealType, Recipe[]>\n  ): MealPlan {\n    const mealPlan: MealPlan = {\n      userId: userProfile.id,\n      startDate: new Date(),\n      endDate: new Date(Date.now() + 42 * 24 * 60 * 60 * 1000), // 42 days later\n      weeks: []\n    };\n    \n    // Generate 6 weeks\n    for (let week = 0; week < 6; week++) {\n      const weekPlan: WeekPlan = { days: [] };\n      \n      // Generate 7 days for each week\n      for (let day = 0; day < 7; day++) {\n        const isFastDay = this.isFastDay(dietaryApproach, week, day);\n        const dayPlan = this.generateDayPlan(\n          userProfile,\n          dietaryApproach,\n          filteredRecipesByMealType,\n          isFastDay\n        );\n        \n        weekPlan.days.push(dayPlan);\n      }\n      \n      mealPlan.weeks.push(weekPlan);\n    }\n    \n    return mealPlan;\n  }\n  \n  private isFastDay(dietaryApproach: DietaryApproach, week: number, day: number): boolean {\n    if (dietaryApproach.id !== '5:2') {\n      return false;\n    }\n    \n    // Implement 5:2 fast day pattern (e.g., Monday and Thursday)\n    return day === 1 || day === 4; // 0 = Sunday, 1 = Monday, etc.\n  }\n}\n```\n\n### 6. Shopping List Generation\n- Implement the `ShoppingListService` to generate weekly shopping lists\n- Aggregate ingredients across recipes\n- Group ingredients by category\n- Calculate quantities needed\n\n```typescript\nclass ShoppingListService {\n  generateShoppingList(weekPlan: WeekPlan): ShoppingList {\n    const ingredientMap = new Map<string, ShoppingListItem>();\n    \n    // Iterate through all meals in the week\n    for (const day of weekPlan.days) {\n      for (const meal of day.meals) {\n        for (const ingredient of meal.recipe.ingredients) {\n          if (ingredientMap.has(ingredient.id)) {\n            // Update quantity if ingredient already in list\n            const existingItem = ingredientMap.get(ingredient.id)!;\n            existingItem.quantity += ingredient.quantity;\n          } else {\n            // Add new ingredient to list\n            ingredientMap.set(ingredient.id, {\n              ingredient: ingredient,\n              quantity: ingredient.quantity,\n              unit: ingredient.unit,\n              category: ingredient.category\n            });\n          }\n        }\n      }\n    }\n    \n    // Convert map to array and sort by category\n    const items = Array.from(ingredientMap.values())\n      .sort((a, b) => a.category.localeCompare(b.category));\n    \n    return {\n      weekNumber: weekPlan.weekNumber,\n      items: items\n    };\n  }\n}\n```\n\n### 7. Integration with Dietary Approaches\n- Ensure the algorithm handles all 7 dietary approaches:\n  - Keto: High fat, very low carb\n  - Sense: Balanced macros with focus on whole foods\n  - LCHF/Paleo: Low carb, higher fat, focus on unprocessed foods\n  - Anti-inflammatory: Emphasis on anti-inflammatory foods\n  - Mediterranean: Plant-based with healthy fats\n  - Flexitarian: Primarily plant-based with occasional meat\n  - 5:2: Normal eating 5 days, restricted calories (500) for 2 days\n\n```typescript\n// Example implementation for handling different dietary approaches\nclass DietaryApproachHandler {\n  getApproachSpecificRules(approachId: string): ApproachRules {\n    switch (approachId) {\n      case 'keto':\n        return {\n          maxCarbsPercentage: 0.05, // 5% of calories from carbs\n          minFatPercentage: 0.70,   // 70% of calories from fat\n          preferredIngredients: ['avocado', 'olive oil', 'fatty fish'],\n          restrictedIngredients: ['sugar', 'grains', 'starchy vegetables']\n        };\n      case '5:2':\n        return {\n          fastDays: 2,\n          fastDayCalories: 500,\n          normalDayCalculation: 'standard',\n          fastDayMealStructure: [\n            { type: 'breakfast', percentage: 0.3 },\n            { type: 'dinner', percentage: 0.7 }\n          ]\n        };\n      // Additional cases for other dietary approaches\n      default:\n        return this.getDefaultRules();\n    }\n  }\n}\n```\n\n### 8. Performance Optimization\n- Implement caching for frequently used calculations\n- Use efficient algorithms for recipe matching and filtering\n- Consider pre-computing common meal combinations\n\n### 9. Error Handling and Edge Cases\n- Handle cases where no suitable recipes are found\n- Implement fallback strategies for strict dietary requirements\n- Add validation for user inputs to prevent algorithm failures",
        "testStrategy": "## Test Strategy\n\n### 1. Unit Tests\n- Test each service component independently:\n\n```typescript\ndescribe('MacroCalculatorService', () => {\n  const service = new MacroCalculatorService();\n  \n  test('calculates BMR correctly for male', () => {\n    const profile = {\n      gender: 'male',\n      weight: 80, // kg\n      height: 180, // cm\n      age: 30\n    };\n    const bmr = service.calculateBMR(profile.weight, profile.height, profile.age, profile.gender);\n    expect(bmr).toBeCloseTo(1810, 0); // Expected BMR within 0 decimal places\n  });\n  \n  test('handles 5:2 fast day calculations correctly', () => {\n    const profile = createMockUserProfile();\n    const dietaryApproach = { id: '5:2', name: '5:2 Diet', macroRatios: {...} };\n    \n    const fastDayMacros = service.calculateDailyMacros(profile, dietaryApproach, true);\n    \n    expect(fastDayMacros.calories).toBe(500);\n    expect(fastDayMacros.protein + fastDayMacros.carbs * 4 + fastDayMacros.fat * 9).toBeCloseTo(500, 0);\n  });\n});\n\ndescribe('RecipeFilterService', () => {\n  const service = new RecipeFilterService();\n  \n  test('filters out recipes with excluded ingredients', () => {\n    const recipes = [\n      { id: '1', name: 'Recipe with nuts', ingredients: [{ id: 'nuts', name: 'Nuts' }] },\n      { id: '2', name: 'Recipe without nuts', ingredients: [{ id: 'apple', name: 'Apple' }] }\n    ];\n    \n    const filtered = service.filterRecipes(\n      recipes,\n      mockDietaryApproach,\n      ['nuts'],\n      'breakfast',\n      mockMacroRange\n    );\n    \n    expect(filtered.length).toBe(1);\n    expect(filtered[0].id).toBe('2');\n  });\n});\n```\n\n### 2. Integration Tests\n- Test the complete meal plan generation process:\n\n```typescript\ndescribe('MealPlanGenerator Integration', () => {\n  const generator = createMealPlanGenerator();\n  \n  test('generates a complete 6-week meal plan', async () => {\n    const userProfile = createMockUserProfile();\n    const mealPlan = await generator.generateMealPlan(userProfile);\n    \n    // Verify structure\n    expect(mealPlan.weeks.length).toBe(6);\n    expect(mealPlan.weeks[0].days.length).toBe(7);\n    \n    // Verify each day has the correct number of meals\n    const day1 = mealPlan.weeks[0].days[0];\n    expect(day1.meals.length).toBe(userProfile.dietaryApproach.mealStructure.meals.length);\n  });\n  \n  test('handles 5:2 diet correctly', async () => {\n    const userProfile = {\n      ...createMockUserProfile(),\n      dietaryApproach: { id: '5:2', name: '5:2 Diet', macroRatios: {...} }\n    };\n    \n    const mealPlan = await generator.generateMealPlan(userProfile);\n    \n    // Check for fast days (e.g., Monday and Thursday)\n    const week1 = mealPlan.weeks[0];\n    const monday = week1.days[1]; // 0-indexed, 1 = Monday\n    const thursday = week1.days[4]; // 0-indexed, 4 = Thursday\n    \n    // Verify fast days have reduced calories\n    expect(monday.totalCalories).toBeLessThanOrEqual(550); // Allow small buffer\n    expect(thursday.totalCalories).toBeLessThanOrEqual(550);\n    \n    // Verify non-fast days have normal calories\n    const tuesday = week1.days[2];\n    expect(tuesday.totalCalories).toBeGreaterThan(1000); // Assuming normal day > 1000 calories\n  });\n});\n```\n\n### 3. Performance Tests\n- Test algorithm performance with large recipe databases:\n\n```typescript\ndescribe('MealPlanGenerator Performance', () => {\n  test('generates meal plan within acceptable time limit', async () => {\n    const userProfile = createMockUserProfile();\n    const largeRecipeDatabase = generateLargeRecipeDatabase(1000); // 1000 recipes\n    \n    const startTime = Date.now();\n    await generator.generateMealPlan(userProfile, largeRecipeDatabase);\n    const endTime = Date.now();\n    \n    const executionTime = endTime - startTime;\n    expect(executionTime).toBeLessThan(5000); // Should complete in under 5 seconds\n  });\n});\n```\n\n### 4. Edge Case Tests\n- Test the algorithm with challenging constraints:\n\n```typescript\ndescribe('MealPlanGenerator Edge Cases', () => {\n  test('handles multiple dietary restrictions', async () => {\n    const userProfile = {\n      ...createMockUserProfile(),\n      exclusions: ['dairy', 'gluten', 'nuts', 'eggs', 'soy']\n    };\n    \n    const mealPlan = await generator.generateMealPlan(userProfile);\n    \n    // Verify no meals contain excluded ingredients\n    for (const week of mealPlan.weeks) {\n      for (const day of week.days) {\n        for (const meal of day.meals) {\n          const hasExcludedIngredients = meal.recipe.ingredients.some(\n            ingredient => userProfile.exclusions.includes(ingredient.category)\n          );\n          expect(hasExcludedIngredients).toBe(false);\n        }\n      }\n    }\n  });\n  \n  test('handles case with very few matching recipes', async () => {\n    const userProfile = createVeryRestrictiveUserProfile();\n    const limitedRecipeDatabase = createLimitedRecipeDatabase();\n    \n    const mealPlan = await generator.generateMealPlan(userProfile, limitedRecipeDatabase);\n    \n    // Verify a meal plan is still generated\n    expect(mealPlan).toBeDefined();\n    expect(mealPlan.weeks.length).toBe(6);\n    \n    // Check if fallback strategies were employed\n    const fallbackMetrics = generator.getFallbackMetrics();\n    expect(fallbackMetrics.fallbacksUsed).toBeGreaterThan(0);\n  });\n});\n```\n\n### 5. Validation Tests\n- Test that generated meal plans meet nutritional requirements:\n\n```typescript\ndescribe('MealPlan Nutritional Validation', () => {\n  test('meal plan meets macro targets for each dietary approach', async () => {\n    // Test each dietary approach\n    for (const approachId of ['keto', 'sense', 'lchf', 'anti-inflammatory', 'mediterranean', 'flexitarian', '5:2']) {\n      const userProfile = {\n        ...createMockUserProfile(),\n        dietaryApproach: { id: approachId, name: `${approachId} Diet`, macroRatios: {...} }\n      };\n      \n      const mealPlan = await generator.generateMealPlan(userProfile);\n      \n      // Calculate average macros across non-fast days\n      const macroStats = calculateAverageMacros(mealPlan, approachId === '5:2');\n      \n      // Verify macros match dietary approach targets\n      const targetRatios = getDietaryApproachMacroRatios(approachId);\n      expect(macroStats.proteinPercentage).toBeCloseTo(targetRatios.protein, 1);\n      expect(macroStats.carbsPercentage).toBeCloseTo(targetRatios.carbs, 1);\n      expect(macroStats.fatPercentage).toBeCloseTo(targetRatios.fat, 1);\n    }\n  });\n});\n```\n\n### 6. User Acceptance Tests\n- Create test scenarios that simulate real user profiles:\n\n```typescript\ndescribe('User Acceptance Tests', () => {\n  test('generates appropriate meal plan for weight loss goal', async () => {\n    const userProfile = {\n      ...createMockUserProfile(),\n      goal: 'weight_loss',\n      currentWeight: 90,\n      targetWeight: 80\n    };\n    \n    const mealPlan = await generator.generateMealPlan(userProfile);\n    \n    // Verify calorie deficit\n    const avgDailyCalories = calculateAverageDailyCalories(mealPlan);\n    const bmr = calculateBMR(userProfile);\n    const tdee = bmr * getActivityMultiplier(userProfile.activityLevel);\n    \n    expect(avgDailyCalories).toBeLessThan(tdee);\n    expect(tdee - avgDailyCalories).toBeGreaterThanOrEqual(500); // At least 500 calorie deficit\n  });\n  \n  test('shopping list contains all required ingredients', async () => {\n    const userProfile = createMockUserProfile();\n    const mealPlan = await generator.generateMealPlan(userProfile);\n    \n    // Generate shopping list for first week\n    const shoppingList = generator.generateShoppingList(mealPlan.weeks[0]);\n    \n    // Collect all ingredients used in the first week\n    const usedIngredients = new Set();\n    for (const day of mealPlan.weeks[0].days) {\n      for (const meal of day.meals) {\n        for (const ingredient of meal.recipe.ingredients) {\n          usedIngredients.add(ingredient.id);\n        }\n      }\n    }\n    \n    // Verify all used ingredients are in the shopping list\n    for (const ingredientId of usedIngredients) {\n      const foundInList = shoppingList.items.some(item => item.ingredient.id === ingredientId);\n      expect(foundInList).toBe(true);\n    }\n  });\n});\n```",
        "status": "pending",
        "dependencies": [
          1,
          2,
          3
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Macro Calculation Service",
            "description": "Develop the MacroCalculatorService to determine daily caloric and macronutrient needs based on user profile, dietary approach, and special handling for 5:2 diet fast days.",
            "dependencies": [],
            "details": "Create a service that calculates BMR using the Mifflin-St Jeor equation, applies activity multipliers, adjusts for goals (weight loss, maintenance, gain), and handles special cases for the 5:2 diet. Implement methods to calculate macros based on dietary approach ratios and support different calculation methods for each of the 7 dietary approaches. Include proper handling of fast days (500 calorie days) for the 5:2 diet.",
            "status": "done",
            "testStrategy": "Write unit tests to verify BMR calculations for different genders and profiles, test activity multiplier applications, verify goal adjustments, and ensure proper handling of 5:2 diet fast days. Create test cases for each dietary approach to confirm correct macro distributions."
          },
          {
            "id": 2,
            "title": "Develop Recipe Filtering Service",
            "description": "Create the RecipeFilterService to filter recipes based on dietary approach compatibility, user exclusions, allergies, macro requirements, and meal types.",
            "dependencies": [],
            "details": "Implement filtering logic that evaluates recipes against multiple criteria: compatibility with dietary approach, absence of excluded ingredients or allergens, appropriateness for specific meal types (breakfast, lunch, dinner, snack), and alignment with target macro ranges. Design the service to efficiently handle large recipe databases and provide meaningful results even with strict filtering criteria.",
            "status": "done",
            "testStrategy": "Test the filtering service with various combinations of dietary approaches and exclusions. Verify that recipes containing excluded ingredients are properly filtered out. Confirm that meal type filtering works correctly. Test edge cases such as very restrictive filtering criteria to ensure the system handles situations where few or no recipes match."
          },
          {
            "id": 3,
            "title": "Create Meal Distribution Service",
            "description": "Implement the MealDistributionService to distribute daily calories and macros across different meals based on dietary approach and meal structure.",
            "dependencies": [
              "4.1"
            ],
            "details": "Develop logic to distribute calculated daily macros across multiple meals according to the meal structure defined by each dietary approach. Support different meal patterns (e.g., 3 meals vs. intermittent fasting patterns) and ensure balanced macro distribution throughout the day. Implement special handling for approaches like 5:2 that have unique meal distribution requirements on fast days.",
            "status": "pending",
            "testStrategy": "Test the distribution of calories and macros across different meal structures. Verify that percentages are calculated correctly and that the sum of distributed macros equals the daily total. Test special cases like the 5:2 diet's fast days to ensure proper distribution of the limited 500 calories."
          },
          {
            "id": 4,
            "title": "Build Meal Plan Assembly System",
            "description": "Develop the MealPlanAssembler to create complete 6-week meal plans with appropriate variation patterns and special handling for different dietary approaches.",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3"
            ],
            "details": "Create a system that assembles a complete 6-week meal plan by generating daily meal plans for 42 consecutive days. Implement variation patterns to avoid meal repetition and ensure dietary diversity. Add special handling for the 5:2 diet by alternating between normal and fast days according to the recommended pattern. Include logic to ensure nutritional adequacy across the entire meal plan period.",
            "status": "pending",
            "testStrategy": "Test the generation of complete 6-week meal plans. Verify that the correct number of days and weeks are created. Check for appropriate meal variation to avoid excessive repetition. For the 5:2 diet, confirm that fast days are correctly scheduled and have appropriate calorie restrictions. Validate that the assembled meal plan meets the user's nutritional requirements."
          },
          {
            "id": 5,
            "title": "Implement Shopping List Generation Service",
            "description": "Create the ShoppingListService to generate weekly shopping lists by aggregating ingredients from meal plans, grouping by category, and calculating required quantities.",
            "dependencies": [
              "4.4"
            ],
            "details": "Develop a service that extracts all ingredients from a week's meal plan, combines duplicate ingredients, calculates total quantities needed, and organizes items by category for easy shopping. Implement logic to handle different units of measurement and convert between them when necessary. Add functionality to optimize quantities to reduce food waste and estimate costs based on ingredient prices.",
            "status": "pending",
            "testStrategy": "Test the aggregation of ingredients across multiple recipes. Verify that duplicate ingredients are properly combined and quantities are correctly summed. Check that ingredients are grouped into appropriate categories. Test unit conversion logic to ensure quantities are expressed consistently. Validate that the generated shopping list contains all necessary ingredients for the week's meals."
          }
        ]
      },
      {
        "id": 5,
        "title": "PDF Generation System for 6-Week Meal Plans",
        "description": "Develop a PDF generation system that creates professional, personalized 6-week meal plan documents with user details, meal plans, shopping lists, educational content, progress tracking, and recipes, including admin validation capabilities and security features.",
        "details": "## Implementation Details\n\n### 1. PDF Generation Architecture\n- Implement a service-based architecture using a PDF generation library like PDFKit, jsPDF, or Puppeteer\n- Create a `MealPlanPdfService` class to orchestrate the PDF generation process\n- Develop specialized components for each section of the PDF\n\n```typescript\n// Core PDF generator service\nclass MealPlanPdfService {\n  constructor(\n    private userService: UserService,\n    private mealPlanService: MealPlanService,\n    private templateService: TemplateService,\n    private securityService: SecurityService\n  ) {}\n\n  async generateMealPlanPdf(userId: string, mealPlanId: string): Promise<Buffer> {\n    // Fetch required data\n    const user = await this.userService.getUserById(userId);\n    const mealPlan = await this.mealPlanService.getMealPlanById(mealPlanId);\n    \n    // Generate PDF\n    const pdfBuffer = await this.buildPdf(user, mealPlan);\n    \n    // Apply security features\n    return this.securityService.applyWatermark(pdfBuffer, user);\n  }\n  \n  private async buildPdf(user: User, mealPlan: MealPlan): Promise<Buffer> {\n    // Implementation details for building the PDF\n  }\n}\n```\n\n### 2. PDF Layout and Sections\n- Design a professional, branded layout template with consistent styling\n- Implement the following sections:\n  - Cover page with user's name and personalized introduction\n  - Table of contents\n  - Dietary approach overview and personalization details\n  - 42 days of meal plans (6 weeks) with daily breakdowns\n  - Weekly shopping lists\n  - Nutritional education section\n  - Progress tracking pages\n  - Recipe collection with images and instructions\n\n```typescript\n// Template service for managing PDF sections\nclass TemplateService {\n  async renderCoverPage(doc: PDFDocument, user: User, mealPlan: MealPlan): Promise<void> {\n    // Render cover page with branding, user name, and introduction\n  }\n  \n  async renderMealPlanSection(doc: PDFDocument, mealPlan: MealPlan): Promise<void> {\n    // Render 6 weeks of meal plans with daily breakdowns\n  }\n  \n  async renderShoppingLists(doc: PDFDocument, mealPlan: MealPlan): Promise<void> {\n    // Generate and render weekly shopping lists\n  }\n  \n  // Additional rendering methods for other sections\n}\n```\n\n### 3. Data Integration\n- Integrate with the meal plan generation algorithm to fetch personalized meal plans\n- Pull user profile data for personalization\n- Retrieve recipe details and images from the database\n- Generate shopping lists based on meal plan ingredients\n\n### 4. Security Features\n- Implement watermarking with user-specific information\n- Add document protection to prevent unauthorized editing\n- Include unique document identifiers for tracking\n\n```typescript\n// Security service for PDF protection\nclass SecurityService {\n  async applyWatermark(pdfBuffer: Buffer, user: User): Promise<Buffer> {\n    // Apply transparent watermark with user information\n    // Return protected PDF buffer\n  }\n  \n  async applyDocumentProtection(pdfBuffer: Buffer): Promise<Buffer> {\n    // Apply password protection or other security measures\n    // Return protected PDF buffer\n  }\n}\n```\n\n### 5. Admin Interface\n- Create an admin dashboard component for PDF validation and editing\n- Implement preview functionality for admins to review generated PDFs\n- Add editing capabilities for admins to modify PDF content before final generation\n- Include approval workflow for PDF generation\n\n```typescript\n// Admin controller for PDF management\nclass AdminPdfController {\n  constructor(private mealPlanPdfService: MealPlanPdfService) {}\n  \n  async previewPdf(userId: string, mealPlanId: string): Promise<Buffer> {\n    // Generate preview PDF for admin review\n  }\n  \n  async editPdfContent(userId: string, mealPlanId: string, edits: PdfEdits): Promise<void> {\n    // Apply admin edits to PDF content\n  }\n  \n  async approvePdf(userId: string, mealPlanId: string): Promise<void> {\n    // Mark PDF as approved for generation\n  }\n}\n```\n\n### 6. Performance Optimization\n- Implement caching for frequently accessed templates and assets\n- Use worker threads or background jobs for PDF generation to avoid blocking the main thread\n- Optimize image processing for faster rendering\n\n### 7. Error Handling and Logging\n- Implement comprehensive error handling for PDF generation failures\n- Add detailed logging for debugging and monitoring\n- Create retry mechanisms for failed generation attempts",
        "testStrategy": "## Test Strategy\n\n### 1. Unit Tests\n- Test each component of the PDF generation system independently:\n\n```typescript\ndescribe('MealPlanPdfService', () => {\n  let service: MealPlanPdfService;\n  let mockUserService: jest.Mocked<UserService>;\n  let mockMealPlanService: jest.Mocked<MealPlanService>;\n  \n  beforeEach(() => {\n    mockUserService = {\n      getUserById: jest.fn()\n    } as any;\n    \n    mockMealPlanService = {\n      getMealPlanById: jest.fn()\n    } as any;\n    \n    service = new MealPlanPdfService(\n      mockUserService,\n      mockMealPlanService,\n      {} as any,\n      {} as any\n    );\n  });\n  \n  test('should fetch user and meal plan data when generating PDF', async () => {\n    // Arrange\n    const userId = 'user-123';\n    const mealPlanId = 'plan-456';\n    mockUserService.getUserById.mockResolvedValue({ id: userId, name: 'Test User' });\n    mockMealPlanService.getMealPlanById.mockResolvedValue({ id: mealPlanId });\n    \n    // Act\n    await service.generateMealPlanPdf(userId, mealPlanId);\n    \n    // Assert\n    expect(mockUserService.getUserById).toHaveBeenCalledWith(userId);\n    expect(mockMealPlanService.getMealPlanById).toHaveBeenCalledWith(mealPlanId);\n  });\n});\n```\n\n### 2. Integration Tests\n- Test the integration between the PDF generation service and other system components:\n\n```typescript\ndescribe('PDF Generation Integration', () => {\n  test('should generate a complete PDF with all required sections', async () => {\n    // Arrange\n    const userId = 'user-123';\n    const mealPlanId = 'plan-456';\n    \n    // Act\n    const pdfBuffer = await pdfGenerationService.generateMealPlanPdf(userId, mealPlanId);\n    \n    // Assert\n    const pdfText = await extractTextFromPdf(pdfBuffer);\n    expect(pdfText).toContain('6-Week Meal Plan');\n    expect(pdfText).toContain('Shopping List');\n    // Additional assertions for expected content\n  });\n});\n```\n\n### 3. Visual Regression Tests\n- Implement visual regression testing to ensure PDF layout and styling remains consistent:\n\n```typescript\ndescribe('PDF Visual Regression', () => {\n  test('should match the expected layout for cover page', async () => {\n    // Generate PDF and extract first page as image\n    const coverPageImage = await generateCoverPageImage();\n    \n    // Compare with baseline image\n    expect(coverPageImage).toMatchImageSnapshot();\n  });\n});\n```\n\n### 4. Security Testing\n- Test watermarking and document protection features:\n\n```typescript\ndescribe('PDF Security Features', () => {\n  test('should apply watermark with user information', async () => {\n    // Generate PDF with watermark\n    const user = { id: 'user-123', name: 'Test User', email: 'test@example.com' };\n    const pdfBuffer = await securityService.applyWatermark(rawPdfBuffer, user);\n    \n    // Extract watermark text\n    const watermarkText = await extractWatermarkFromPdf(pdfBuffer);\n    \n    // Assert watermark contains user information\n    expect(watermarkText).toContain(user.name);\n    expect(watermarkText).toContain(user.email);\n  });\n});\n```\n\n### 5. Performance Testing\n- Measure PDF generation time and resource usage:\n\n```typescript\ndescribe('PDF Generation Performance', () => {\n  test('should generate PDF within acceptable time limit', async () => {\n    const startTime = Date.now();\n    \n    await pdfGenerationService.generateMealPlanPdf('user-123', 'plan-456');\n    \n    const endTime = Date.now();\n    const duration = endTime - startTime;\n    \n    expect(duration).toBeLessThan(5000); // Should complete within 5 seconds\n  });\n});\n```\n\n### 6. Admin Interface Testing\n- Test admin preview and editing functionality:\n\n```typescript\ndescribe('Admin PDF Management', () => {\n  test('should allow admin to preview PDF before generation', async () => {\n    // Arrange\n    const adminController = new AdminPdfController(pdfGenerationService);\n    \n    // Act\n    const previewBuffer = await adminController.previewPdf('user-123', 'plan-456');\n    \n    // Assert\n    expect(previewBuffer).toBeTruthy();\n    // Additional assertions for preview content\n  });\n  \n  test('should apply admin edits to PDF content', async () => {\n    // Arrange\n    const adminController = new AdminPdfController(pdfGenerationService);\n    const edits = {\n      introduction: 'Custom introduction text',\n      sections: {\n        nutritionalEducation: 'Modified educational content'\n      }\n    };\n    \n    // Act\n    await adminController.editPdfContent('user-123', 'plan-456', edits);\n    const pdfBuffer = await pdfGenerationService.generateMealPlanPdf('user-123', 'plan-456');\n    \n    // Assert\n    const pdfText = await extractTextFromPdf(pdfBuffer);\n    expect(pdfText).toContain('Custom introduction text');\n    expect(pdfText).toContain('Modified educational content');\n  });\n});\n```\n\n### 7. End-to-End Testing\n- Test the complete PDF generation flow from user request to final document:\n\n```typescript\ndescribe('PDF Generation E2E', () => {\n  test('should generate and deliver PDF to user', async () => {\n    // Simulate user request for PDF generation\n    const response = await request(app)\n      .post('/api/meal-plans/123/generate-pdf')\n      .set('Authorization', `Bearer ${userToken}`);\n    \n    // Assert successful response\n    expect(response.status).toBe(200);\n    expect(response.headers['content-type']).toBe('application/pdf');\n    expect(response.body).toBeTruthy();\n  });\n});\n```",
        "status": "pending",
        "dependencies": [
          4,
          1,
          2,
          3
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "PDF Generation Architecture Setup",
            "description": "Implement the core PDF generation service architecture using a library like PDFKit, jsPDF, or Puppeteer, and create the main service class structure.",
            "dependencies": [],
            "details": "1. Research and select the most appropriate PDF generation library (PDFKit, jsPDF, or Puppeteer)\n2. Create the `MealPlanPdfService` class with dependency injection for required services\n3. Implement the main generation method flow with proper error handling\n4. Set up the basic PDF document structure with configuration options\n5. Create interfaces for all data models needed for PDF generation\n6. Implement a caching mechanism for improved performance",
            "status": "done",
            "testStrategy": "1. Unit test the `MealPlanPdfService` class with mocked dependencies\n2. Test PDF generation with various input scenarios\n3. Verify error handling for missing data\n4. Benchmark performance with different document sizes\n5. Test memory usage during generation of large documents"
          },
          {
            "id": 2,
            "title": "PDF Layout and Section Components",
            "description": "Design and implement all PDF section components including cover page, meal plans, shopping lists, educational content, progress tracking, and recipe collection.",
            "dependencies": [
              "5.1"
            ],
            "details": "1. Create a `TemplateService` class with methods for each PDF section\n2. Design a consistent, branded layout template with proper styling\n3. Implement rendering methods for all required sections: cover page, table of contents, meal plans, shopping lists, educational content, progress tracking, and recipes\n4. Add support for images, tables, and formatted text\n5. Ensure proper pagination and section breaks\n6. Implement dynamic content sizing based on available space",
            "status": "in-progress",
            "testStrategy": "1. Unit test each section rendering method\n2. Verify correct layout and styling across different content types\n3. Test pagination with various content lengths\n4. Validate image rendering quality and positioning\n5. Test table generation with different data structures"
          },
          {
            "id": 3,
            "title": "Data Integration and Content Generation",
            "description": "Integrate the PDF system with meal plan data, user profiles, recipes, and shopping lists, and implement content generation for all sections.",
            "dependencies": [
              "5.1",
              "5.2"
            ],
            "details": "1. Create data fetching services to retrieve meal plans, user profiles, recipes, and shopping lists\n2. Implement content generation algorithms for each section\n3. Generate shopping lists based on meal plan ingredients\n4. Format recipe details with images and instructions\n5. Create personalized content based on user profile data\n6. Implement data transformation utilities to convert raw data into PDF-ready format",
            "status": "pending",
            "testStrategy": "1. Test data retrieval with mock services\n2. Verify content generation with various input data\n3. Test shopping list generation algorithm\n4. Validate recipe formatting with different recipe structures\n5. Test personalization features with different user profiles"
          },
          {
            "id": 4,
            "title": "Security Features Implementation",
            "description": "Implement PDF security features including watermarking, document protection, and unique identifiers for tracking.",
            "dependencies": [
              "5.1",
              "5.3"
            ],
            "details": "1. Create a `SecurityService` class for PDF protection features\n2. Implement watermarking with user-specific information\n3. Add document protection to prevent unauthorized editing\n4. Include unique document identifiers for tracking\n5. Implement digital signatures if required\n6. Add metadata for document tracking and validation",
            "status": "pending",
            "testStrategy": "1. Test watermark application with various user data\n2. Verify document protection prevents unauthorized editing\n3. Test unique identifier generation and embedding\n4. Validate digital signature implementation\n5. Test metadata generation and retrieval"
          },
          {
            "id": 5,
            "title": "Admin Interface for PDF Management",
            "description": "Create an admin dashboard component for PDF validation, preview, editing, and approval workflow.",
            "dependencies": [
              "5.1",
              "5.2",
              "5.3",
              "5.4"
            ],
            "details": "1. Implement an `AdminPdfController` class for PDF management\n2. Create preview functionality for admins to review generated PDFs\n3. Add editing capabilities for admins to modify PDF content before final generation\n4. Implement an approval workflow for PDF generation\n5. Add logging and audit trail for admin actions\n6. Create a user interface for admin PDF management",
            "status": "pending",
            "testStrategy": "1. Test preview generation with various meal plans\n2. Verify editing functionality preserves document integrity\n3. Test approval workflow with different user scenarios\n4. Validate logging and audit trail functionality\n5. Test user interface components with different screen sizes"
          }
        ]
      },
      {
        "id": 6,
        "title": "Nutritional Deficiency Assessment System",
        "description": "Create a system that evaluates user symptoms and lifestyle factors to identify potential nutritional deficiencies, providing personalized recommendations for common deficiencies like Iron, B12, D3, Magnesium, and Omega-3.",
        "details": "## Implementation Details\n\n### 1. Data Model Design\n- Create TypeScript interfaces for nutritional deficiencies, symptoms, and assessment results:\n\n```typescript\ninterface NutritionalDeficiency {\n  id: string;\n  name: string;\n  description: string;\n  commonSymptoms: string[];\n  riskFactors: string[];\n  recommendedIntake: string;\n  foodSources: FoodSource[];\n  supplementRecommendations: SupplementRecommendation[];\n}\n\ninterface FoodSource {\n  name: string;\n  nutrientContent: string; // e.g., \"High\", \"Medium\", \"Low\"\n  servingSuggestion: string;\n  dietaryApproachCompatibility: string[]; // e.g., [\"Keto\", \"Mediterranean\"]\n}\n\ninterface SupplementRecommendation {\n  type: string;\n  dosage: string;\n  timing: string;\n  precautions: string[];\n}\n\ninterface UserSymptom {\n  id: string;\n  description: string;\n  severity: 'mild' | 'moderate' | 'severe';\n  duration: 'recent' | 'ongoing' | 'chronic';\n  relatedDeficiencies: string[]; // IDs of potentially related deficiencies\n}\n\ninterface LifestyleFactor {\n  id: string;\n  category: 'diet' | 'exercise' | 'sleep' | 'stress' | 'medical';\n  description: string;\n  impactedNutrients: string[]; // IDs of potentially impacted nutrients\n}\n\ninterface AssessmentResult {\n  userId: string;\n  date: Date;\n  potentialDeficiencies: PotentialDeficiency[];\n  overallNutritionalScore: number;\n}\n\ninterface PotentialDeficiency {\n  deficiencyId: string;\n  probabilityScore: number; // 0-100\n  matchedSymptoms: string[];\n  matchedFactors: string[];\n  personalizedRecommendations: string[];\n  expectedTimeframe: string; // e.g., \"2-4 weeks\"\n}\n```\n\n### 2. Assessment Algorithm\n- Implement a rule-based expert system for evaluating nutritional deficiencies:\n\n```typescript\nclass NutritionalDeficiencyAssessor {\n  constructor(\n    private deficiencyRepository: DeficiencyRepository,\n    private symptomRepository: SymptomRepository,\n    private userProfileService: UserProfileService,\n    private dietaryApproachService: DietaryApproachService\n  ) {}\n\n  async assessUser(userId: string, reportedSymptoms: UserSymptom[], lifestyleFactors: LifestyleFactor[]): Promise<AssessmentResult> {\n    const userProfile = await this.userProfileService.getUserProfile(userId);\n    const dietaryApproach = await this.dietaryApproachService.getUserDietaryApproach(userId);\n    \n    // Get all potential deficiencies\n    const deficiencies = await this.deficiencyRepository.getAllDeficiencies();\n    \n    // Calculate probability scores for each deficiency\n    const potentialDeficiencies = deficiencies.map(deficiency => {\n      const matchedSymptoms = this.matchSymptoms(deficiency, reportedSymptoms);\n      const matchedFactors = this.matchLifestyleFactors(deficiency, lifestyleFactors, userProfile);\n      \n      const probabilityScore = this.calculateProbabilityScore(\n        deficiency, \n        matchedSymptoms, \n        matchedFactors, \n        userProfile, \n        dietaryApproach\n      );\n      \n      return {\n        deficiencyId: deficiency.id,\n        probabilityScore,\n        matchedSymptoms: matchedSymptoms.map(s => s.id),\n        matchedFactors: matchedFactors.map(f => f.id),\n        personalizedRecommendations: this.generateRecommendations(deficiency, userProfile, dietaryApproach),\n        expectedTimeframe: this.estimateTimeframe(deficiency, probabilityScore)\n      };\n    });\n    \n    // Filter to only include significant potential deficiencies (score > threshold)\n    const significantDeficiencies = potentialDeficiencies\n      .filter(pd => pd.probabilityScore > 30)\n      .sort((a, b) => b.probabilityScore - a.probabilityScore);\n    \n    const overallScore = this.calculateOverallNutritionalScore(userProfile, significantDeficiencies);\n    \n    return {\n      userId,\n      date: new Date(),\n      potentialDeficiencies: significantDeficiencies,\n      overallNutritionalScore: overallScore\n    };\n  }\n  \n  // Helper methods\n  private matchSymptoms(deficiency: NutritionalDeficiency, reportedSymptoms: UserSymptom[]): UserSymptom[] {\n    // Implementation details\n  }\n  \n  private matchLifestyleFactors(deficiency: NutritionalDeficiency, factors: LifestyleFactor[], profile: UserProfile): LifestyleFactor[] {\n    // Implementation details\n  }\n  \n  private calculateProbabilityScore(\n    deficiency: NutritionalDeficiency,\n    matchedSymptoms: UserSymptom[],\n    matchedFactors: LifestyleFactor[],\n    profile: UserProfile,\n    dietaryApproach: DietaryApproach\n  ): number {\n    // Weighted scoring algorithm\n    // Consider symptom severity, duration, demographic risk factors, and dietary approach\n  }\n  \n  private generateRecommendations(\n    deficiency: NutritionalDeficiency, \n    profile: UserProfile,\n    dietaryApproach: DietaryApproach\n  ): string[] {\n    // Generate personalized recommendations based on the user's profile and dietary approach\n  }\n  \n  private estimateTimeframe(deficiency: NutritionalDeficiency, score: number): string {\n    // Estimate expected improvement timeframe based on deficiency type and severity\n  }\n  \n  private calculateOverallNutritionalScore(profile: UserProfile, deficiencies: PotentialDeficiency[]): number {\n    // Calculate overall nutritional health score\n  }\n}\n```\n\n### 3. Assessment Questionnaire UI\n- Create a multi-step questionnaire to collect symptom and lifestyle data:\n\n```typescript\n// React component for the assessment wizard\nconst NutritionalAssessmentWizard: React.FC = () => {\n  const [step, setStep] = useState(1);\n  const [assessmentData, setAssessmentData] = useState({\n    symptoms: [],\n    lifestyleFactors: [],\n    medicalHistory: [],\n    dietaryHabits: []\n  });\n  \n  const updateAssessmentData = (field: string, data: any) => {\n    setAssessmentData(prev => ({\n      ...prev,\n      [field]: data\n    }));\n  };\n  \n  const handleSubmit = async () => {\n    try {\n      const result = await nutritionalAssessmentService.submitAssessment(assessmentData);\n      // Navigate to results page\n    } catch (error) {\n      // Handle error\n    }\n  };\n  \n  return (\n    <div className=\"assessment-wizard\">\n      <ProgressIndicator currentStep={step} totalSteps={4} />\n      \n      {step === 1 && (\n        <SymptomAssessmentStep \n          onNext={() => setStep(2)}\n          updateData={(data) => updateAssessmentData('symptoms', data)}\n          initialData={assessmentData.symptoms}\n        />\n      )}\n      \n      {step === 2 && (\n        <LifestyleFactorsStep \n          onNext={() => setStep(3)}\n          onBack={() => setStep(1)}\n          updateData={(data) => updateAssessmentData('lifestyleFactors', data)}\n          initialData={assessmentData.lifestyleFactors}\n        />\n      )}\n      \n      {step === 3 && (\n        <MedicalHistoryStep \n          onNext={() => setStep(4)}\n          onBack={() => setStep(2)}\n          updateData={(data) => updateAssessmentData('medicalHistory', data)}\n          initialData={assessmentData.medicalHistory}\n        />\n      )}\n      \n      {step === 4 && (\n        <DietaryHabitsStep \n          onSubmit={handleSubmit}\n          onBack={() => setStep(3)}\n          updateData={(data) => updateAssessmentData('dietaryHabits', data)}\n          initialData={assessmentData.dietaryHabits}\n        />\n      )}\n    </div>\n  );\n};\n```\n\n### 4. Results Visualization\n- Implement a comprehensive results dashboard:\n\n```typescript\nconst AssessmentResultsDashboard: React.FC<{ results: AssessmentResult }> = ({ results }) => {\n  return (\n    <div className=\"results-dashboard\">\n      <OverallScoreCard score={results.overallNutritionalScore} />\n      \n      <section className=\"potential-deficiencies\">\n        <h2>Potential Nutritional Gaps</h2>\n        {results.potentialDeficiencies.map(deficiency => (\n          <DeficiencyCard \n            key={deficiency.deficiencyId}\n            deficiency={deficiency}\n            showDetails={deficiency.probabilityScore > 60}\n          />\n        ))}\n      </section>\n      \n      <section className=\"personalized-plan\">\n        <h2>Your Personalized Nutrition Plan</h2>\n        <QuickWinsSection deficiencies={results.potentialDeficiencies} />\n        <TimeframeExpectations deficiencies={results.potentialDeficiencies} />\n        <ActionPlanTimeline deficiencies={results.potentialDeficiencies} />\n      </section>\n      \n      <section className=\"educational-content\">\n        <h2>Understanding Your Nutrition</h2>\n        {results.potentialDeficiencies.map(deficiency => (\n          <EducationalContent key={deficiency.deficiencyId} deficiencyId={deficiency.deficiencyId} />\n        ))}\n      </section>\n    </div>\n  );\n};\n```\n\n### 5. Integration with Meal Planning\n- Connect the deficiency assessment with the meal planning system:\n\n```typescript\nclass NutrientFocusedMealPlanAdapter {\n  constructor(\n    private mealPlanGenerator: MealPlanGenerator,\n    private deficiencyRepository: DeficiencyRepository\n  ) {}\n  \n  async generateNutrientFocusedMealPlan(userId: string, assessmentResult: AssessmentResult): Promise<MealPlan> {\n    // Get detailed deficiency information\n    const deficiencyDetails = await Promise.all(\n      assessmentResult.potentialDeficiencies.map(async pd => {\n        return await this.deficiencyRepository.getDeficiencyById(pd.deficiencyId);\n      })\n    );\n    \n    // Extract food sources to prioritize\n    const priorityFoodSources = deficiencyDetails.flatMap(d => d.foodSources);\n    \n    // Create nutrient-focused meal plan parameters\n    const mealPlanParams = {\n      userId,\n      nutrientFocus: deficiencyDetails.map(d => d.name),\n      priorityFoodSources: priorityFoodSources,\n      // Other standard meal plan parameters\n    };\n    \n    // Generate the meal plan with nutrient focus\n    return await this.mealPlanGenerator.generateMealPlan(mealPlanParams);\n  }\n}\n```\n\n### 6. Deficiency Database\n- Create a comprehensive database of nutritional deficiencies with their symptoms, causes, and recommendations:\n\n```typescript\n// Example data for Iron deficiency\nconst ironDeficiency: NutritionalDeficiency = {\n  id: \"iron-deficiency\",\n  name: \"Iron Deficiency\",\n  description: \"Iron deficiency occurs when the body doesn't have enough iron to produce hemoglobin, which helps red blood cells carry oxygen throughout the body.\",\n  commonSymptoms: [\n    \"Fatigue and weakness\",\n    \"Pale skin\",\n    \"Shortness of breath\",\n    \"Dizziness or lightheadedness\",\n    \"Cold hands and feet\",\n    \"Brittle nails\",\n    \"Headaches\"\n  ],\n  riskFactors: [\n    \"Menstruation\",\n    \"Pregnancy\",\n    \"Vegetarian or vegan diet\",\n    \"Blood loss\",\n    \"Gastrointestinal disorders\"\n  ],\n  recommendedIntake: \"Men: 8mg/day, Women 19-50: 18mg/day, Women 51+: 8mg/day\",\n  foodSources: [\n    {\n      name: \"Red meat (beef, lamb)\",\n      nutrientContent: \"High\",\n      servingSuggestion: \"3-4oz serving, 2-3 times per week\",\n      dietaryApproachCompatibility: [\"Keto\", \"LCHF/Paleo\", \"Flexitarian\"]\n    },\n    {\n      name: \"Spinach\",\n      nutrientContent: \"Medium\",\n      servingSuggestion: \"1 cup cooked, 3-4 times per week\",\n      dietaryApproachCompatibility: [\"Keto\", \"LCHF/Paleo\", \"Anti-inflammatory\", \"Mediterranean\", \"Flexitarian\", \"5:2\", \"Sense\"]\n    },\n    // Additional food sources\n  ],\n  supplementRecommendations: [\n    {\n      type: \"Ferrous sulfate\",\n      dosage: \"325mg, containing 65mg elemental iron\",\n      timing: \"Best absorbed on empty stomach, but may take with food if GI upset occurs\",\n      precautions: [\"May cause constipation\", \"Don't take with calcium or dairy\", \"Take with vitamin C to enhance absorption\"]\n    }\n  ]\n};\n\n// Similar detailed entries for B12, D3, Magnesium, Omega-3, etc.\n```\n\n### 7. Personalization Engine\n- Implement a recommendation engine that tailors advice based on user profile and dietary approach:\n\n```typescript\nclass PersonalizedRecommendationEngine {\n  constructor(\n    private userProfileService: UserProfileService,\n    private dietaryApproachService: DietaryApproachService\n  ) {}\n  \n  async generatePersonalizedRecommendations(\n    userId: string, \n    deficiencies: NutritionalDeficiency[]\n  ): Promise<Map<string, string[]>> {\n    const userProfile = await this.userProfileService.getUserProfile(userId);\n    const dietaryApproach = await this.dietaryApproachService.getUserDietaryApproach(userId);\n    \n    const recommendations = new Map<string, string[]>();\n    \n    for (const deficiency of deficiencies) {\n      const personalizedRecs = [];\n      \n      // Food recommendations based on dietary approach\n      const compatibleFoods = deficiency.foodSources.filter(food => \n        food.dietaryApproachCompatibility.includes(dietaryApproach.name)\n      );\n      \n      if (compatibleFoods.length > 0) {\n        personalizedRecs.push(\n          `Focus on adding these ${dietaryApproach.name}-friendly foods to your meals: ${\n            compatibleFoods.slice(0, 3).map(f => f.name).join(', ')\n          }`\n        );\n      }\n      \n      // Supplement recommendations based on user profile\n      if (this.shouldRecommendSupplements(deficiency, userProfile)) {\n        const supplement = this.selectBestSupplement(deficiency, userProfile);\n        personalizedRecs.push(\n          `Consider a ${supplement.type} supplement (${supplement.dosage}) ${supplement.timing}.`\n        );\n      }\n      \n      // Lifestyle modifications\n      personalizedRecs.push(...this.generateLifestyleRecommendations(deficiency, userProfile));\n      \n      // Quick wins\n      personalizedRecs.push(...this.generateQuickWins(deficiency, dietaryApproach));\n      \n      recommendations.set(deficiency.id, personalizedRecs);\n    }\n    \n    return recommendations;\n  }\n  \n  private shouldRecommendSupplements(deficiency: NutritionalDeficiency, profile: UserProfile): boolean {\n    // Logic to determine if supplements should be recommended\n  }\n  \n  private selectBestSupplement(deficiency: NutritionalDeficiency, profile: UserProfile): SupplementRecommendation {\n    // Logic to select the most appropriate supplement form\n  }\n  \n  private generateLifestyleRecommendations(deficiency: NutritionalDeficiency, profile: UserProfile): string[] {\n    // Generate lifestyle modification recommendations\n  }\n  \n  private generateQuickWins(deficiency: NutritionalDeficiency, dietaryApproach: DietaryApproach): string[] {\n    // Generate quick, easy-to-implement recommendations\n  }\n}\n```\n\n### 8. Progress Tracking\n- Implement a system to track user progress and symptom improvements:\n\n```typescript\ninterface ProgressEntry {\n  userId: string;\n  date: Date;\n  symptoms: {\n    symptomId: string;\n    severity: number; // 1-10 scale\n    notes: string;\n  }[];\n  supplementAdherence: number; // Percentage\n  dietaryAdherence: number; // Percentage\n  overallFeeling: number; // 1-10 scale\n}\n\nclass DeficiencyProgressTracker {\n  constructor(private progressRepository: ProgressRepository) {}\n  \n  async recordProgress(entry: ProgressEntry): Promise<void> {\n    await this.progressRepository.saveProgressEntry(entry);\n  }\n  \n  async getProgressReport(userId: string, startDate: Date, endDate: Date): Promise<ProgressReport> {\n    const entries = await this.progressRepository.getEntriesByDateRange(userId, startDate, endDate);\n    \n    // Calculate symptom improvement percentages\n    const symptomImprovements = this.calculateSymptomImprovements(entries);\n    \n    // Calculate adherence averages\n    const supplementAdherence = this.calculateAverageAdherence(entries.map(e => e.supplementAdherence));\n    const dietaryAdherence = this.calculateAverageAdherence(entries.map(e => e.dietaryAdherence));\n    \n    // Generate insights\n    const insights = this.generateInsights(entries, symptomImprovements);\n    \n    return {\n      userId,\n      startDate,\n      endDate,\n      symptomImprovements,\n      supplementAdherence,\n      dietaryAdherence,\n      insights,\n      entries\n    };\n  }\n  \n  private calculateSymptomImprovements(entries: ProgressEntry[]): Map<string, number> {\n    // Calculate improvement percentages for each symptom\n  }\n  \n  private calculateAverageAdherence(adherenceValues: number[]): number {\n    // Calculate average adherence\n  }\n  \n  private generateInsights(entries: ProgressEntry[], improvements: Map<string, number>): string[] {\n    // Generate insights based on progress data\n  }\n}\n```\n\n### 9. Security and Privacy\n- Implement proper security measures for handling sensitive health data:\n\n```typescript\n// Implement data encryption for sensitive health information\nclass HealthDataEncryptionService {\n  private readonly encryptionKey: Buffer;\n  \n  constructor(keyManagementService: KeyManagementService) {\n    this.encryptionKey = keyManagementService.getEncryptionKey();\n  }\n  \n  encryptHealthData(data: any): string {\n    const iv = crypto.randomBytes(16);\n    const cipher = crypto.createCipheriv('aes-256-gcm', this.encryptionKey, iv);\n    \n    let encrypted = cipher.update(JSON.stringify(data), 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    \n    const authTag = cipher.getAuthTag();\n    \n    return JSON.stringify({\n      iv: iv.toString('hex'),\n      encryptedData: encrypted,\n      authTag: authTag.toString('hex')\n    });\n  }\n  \n  decryptHealthData(encryptedData: string): any {\n    const { iv, encryptedData: data, authTag } = JSON.parse(encryptedData);\n    \n    const decipher = crypto.createDecipheriv(\n      'aes-256-gcm', \n      this.encryptionKey, \n      Buffer.from(iv, 'hex')\n    );\n    \n    decipher.setAuthTag(Buffer.from(authTag, 'hex'));\n    \n    let decrypted = decipher.update(data, 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n    \n    return JSON.parse(decrypted);\n  }\n}\n```",
        "testStrategy": "## Test Strategy\n\n### 1. Unit Tests\n- Test the nutritional deficiency assessment algorithm:\n\n```typescript\ndescribe('NutritionalDeficiencyAssessor', () => {\n  let assessor: NutritionalDeficiencyAssessor;\n  let mockDeficiencyRepo: jest.Mocked<DeficiencyRepository>;\n  let mockSymptomRepo: jest.Mocked<SymptomRepository>;\n  let mockUserProfileService: jest.Mocked<UserProfileService>;\n  let mockDietaryApproachService: jest.Mocked<DietaryApproachService>;\n  \n  beforeEach(() => {\n    mockDeficiencyRepo = {\n      getAllDeficiencies: jest.fn(),\n      getDeficiencyById: jest.fn()\n    } as any;\n    \n    mockSymptomRepo = {\n      getAllSymptoms: jest.fn()\n    } as any;\n    \n    mockUserProfileService = {\n      getUserProfile: jest.fn()\n    } as any;\n    \n    mockDietaryApproachService = {\n      getUserDietaryApproach: jest.fn()\n    } as any;\n    \n    assessor = new NutritionalDeficiencyAssessor(\n      mockDeficiencyRepo,\n      mockSymptomRepo,\n      mockUserProfileService,\n      mockDietaryApproachService\n    );\n  });\n  \n  test('should correctly identify iron deficiency based on symptoms', async () => {\n    // Mock data setup\n    const mockUser = { id: 'user1', gender: 'female', age: 35 };\n    const mockDietaryApproach = { name: 'Keto', id: 'keto' };\n    const mockDeficiencies = [\n      {\n        id: 'iron-deficiency',\n        name: 'Iron Deficiency',\n        commonSymptoms: ['fatigue', 'weakness', 'pale skin'],\n        // Other properties\n      }\n    ];\n    \n    const reportedSymptoms = [\n      { id: 'fatigue', description: 'Feeling tired', severity: 'severe', duration: 'chronic', relatedDeficiencies: ['iron-deficiency'] },\n      { id: 'pale-skin', description: 'Pale skin', severity: 'moderate', duration: 'ongoing', relatedDeficiencies: ['iron-deficiency'] }\n    ];\n    \n    const lifestyleFactors = [\n      { id: 'vegetarian-diet', category: 'diet', description: 'Vegetarian diet', impactedNutrients: ['iron-deficiency'] }\n    ];\n    \n    // Setup mocks\n    mockUserProfileService.getUserProfile.mockResolvedValue(mockUser);\n    mockDietaryApproachService.getUserDietaryApproach.mockResolvedValue(mockDietaryApproach);\n    mockDeficiencyRepo.getAllDeficiencies.mockResolvedValue(mockDeficiencies);\n    \n    // Execute\n    const result = await assessor.assessUser('user1', reportedSymptoms, lifestyleFactors);\n    \n    // Assert\n    expect(result.potentialDeficiencies.length).toBeGreaterThan(0);\n    expect(result.potentialDeficiencies[0].deficiencyId).toBe('iron-deficiency');\n    expect(result.potentialDeficiencies[0].probabilityScore).toBeGreaterThan(60);\n    expect(result.potentialDeficiencies[0].matchedSymptoms).toContain('fatigue');\n    expect(result.potentialDeficiencies[0].matchedFactors).toContain('vegetarian-diet');\n  });\n  \n  test('should generate personalized recommendations based on dietary approach', async () => {\n    // Similar test setup\n    // Assert that recommendations are compatible with the user's dietary approach\n  });\n  \n  test('should correctly calculate overall nutritional score', async () => {\n    // Test the overall score calculation logic\n  });\n});\n```\n\n### 2. Integration Tests\n- Test the integration between the assessment system and meal planning:\n\n```typescript\ndescribe('Nutritional Assessment and Meal Planning Integration', () => {\n  let assessmentService: NutritionalAssessmentService;\n  let mealPlanAdapter: NutrientFocusedMealPlanAdapter;\n  \n  beforeEach(() => {\n    // Setup test dependencies\n  });\n  \n  test('should generate meal plan that addresses identified deficiencies', async () => {\n    // Create a mock assessment result with iron and B12 deficiencies\n    const assessmentResult = {\n      userId: 'user1',\n      date: new Date(),\n      potentialDeficiencies: [\n        {\n          deficiencyId: 'iron-deficiency',\n          probabilityScore: 75,\n          // Other properties\n        },\n        {\n          deficiencyId: 'b12-deficiency',\n          probabilityScore: 65,\n          // Other properties\n        }\n      ],\n      overallNutritionalScore: 65\n    };\n    \n    // Generate a meal plan based on the assessment\n    const mealPlan = await mealPlanAdapter.generateNutrientFocusedMealPlan('user1', assessmentResult);\n    \n    // Assert that the meal plan includes foods rich in iron and B12\n    const ironRichFoods = ['beef', 'spinach', 'lentils', 'liver'];\n    const b12RichFoods = ['salmon', 'eggs', 'beef', 'fortified cereals'];\n    \n    let containsIronRichFoods = false;\n    let containsB12RichFoods = false;\n    \n    // Check if meal plan contains foods rich in the deficient nutrients\n    mealPlan.weeks.forEach(week => {\n      week.days.forEach(day => {\n        day.meals.forEach(meal => {\n          meal.recipes.forEach(recipe => {\n            recipe.ingredients.forEach(ingredient => {\n              if (ironRichFoods.some(food => ingredient.name.toLowerCase().includes(food))) {\n                containsIronRichFoods = true;\n              }\n              if (b12RichFoods.some(food => ingredient.name.toLowerCase().includes(food))) {\n                containsB12RichFoods = true;\n              }\n            });\n          });\n        });\n      });\n    });\n    \n    expect(containsIronRichFoods).toBe(true);\n    expect(containsB12RichFoods).toBe(true);\n  });\n});\n```\n\n### 3. UI Component Tests\n- Test the assessment questionnaire UI:\n\n```typescript\ndescribe('NutritionalAssessmentWizard', () => {\n  test('should navigate through all steps correctly', () => {\n    render(<NutritionalAssessmentWizard />);\n    \n    // Step 1: Symptoms\n    expect(screen.getByText('What symptoms are you experiencing?')).toBeInTheDocument();\n    fireEvent.click(screen.getByText('Fatigue'));\n    fireEvent.click(screen.getByText('Next'));\n    \n    // Step 2: Lifestyle Factors\n    expect(screen.getByText('Tell us about your lifestyle')).toBeInTheDocument();\n    fireEvent.click(screen.getByText('Vegetarian diet'));\n    fireEvent.click(screen.getByText('Next'));\n    \n    // Step 3: Medical History\n    expect(screen.getByText('Medical History')).toBeInTheDocument();\n    fireEvent.click(screen.getByText('Next'));\n    \n    // Step 4: Dietary Habits\n    expect(screen.getByText('Dietary Habits')).toBeInTheDocument();\n    fireEvent.click(screen.getByText('Submit'));\n    \n    // Verify submission was attempted\n    expect(mockNutritionalAssessmentService.submitAssessment).toHaveBeenCalled();\n  });\n  \n  test('should correctly update assessment data on each step', () => {\n    render(<NutritionalAssessmentWizard />);\n    \n    // Step 1: Select symptoms\n    fireEvent.click(screen.getByText('Fatigue'));\n    fireEvent.click(screen.getByText('Pale skin'));\n    fireEvent.click(screen.getByText('Next'));\n    \n    // Step 2: Select lifestyle factors\n    fireEvent.click(screen.getByText('Vegetarian diet'));\n    fireEvent.click(screen.getByText('High stress levels'));\n    fireEvent.click(screen.getByText('Next'));\n    \n    // Complete remaining steps\n    fireEvent.click(screen.getByText('Next')); // Medical history\n    fireEvent.click(screen.getByText('Submit')); // Dietary habits\n    \n    // Verify the collected data\n    expect(mockNutritionalAssessmentService.submitAssessment).toHaveBeenCalledWith(\n      expect.objectContaining({\n        symptoms: expect.arrayContaining([\n          expect.objectContaining({ description: 'Fatigue' }),\n          expect.objectContaining({ description: 'Pale skin' })\n        ]),\n        lifestyleFactors: expect.arrayContaining([\n          expect.objectContaining({ description: 'Vegetarian diet' }),\n          expect.objectContaining({ description: 'High stress levels' })\n        ])\n      })\n    );\n  });\n});\n```\n\n### 4. Results Visualization Tests\n- Test the assessment results dashboard:\n\n```typescript\ndescribe('AssessmentResultsDashboard', () => {\n  const mockResults = {\n    userId: 'user1',\n    date: new Date(),\n    potentialDeficiencies: [\n      {\n        deficiencyId: 'iron-deficiency',\n        probabilityScore: 85,\n        matchedSymptoms: ['fatigue', 'pale-skin'],\n        matchedFactors: ['vegetarian-diet'],\n        personalizedRecommendations: [\n          'Include spinach in your meals 3-4 times per week',\n          'Consider a ferrous sulfate supplement'\n        ],\n        expectedTimeframe: '4-6 weeks'\n      },\n      {\n        deficiencyId: 'vitamin-d-deficiency',\n        probabilityScore: 65,\n        matchedSymptoms: ['fatigue', 'muscle-weakness'],\n        matchedFactors: ['limited-sun-exposure'],\n        personalizedRecommendations: [\n          'Spend 15-20 minutes in sunlight daily',\n          'Include fatty fish in your diet twice weekly'\n        ],\n        expectedTimeframe: '8-12 weeks'\n      }\n    ],\n    overallNutritionalScore: 70\n  };\n  \n  test('should display all potential deficiencies', () => {\n    render(<AssessmentResultsDashboard results={mockResults} />);\n    \n    expect(screen.getByText('Iron Deficiency')).toBeInTheDocument();\n    expect(screen.getByText('Vitamin D Deficiency')).toBeInTheDocument();\n  });\n  \n  test('should display personalized recommendations', () => {\n    render(<AssessmentResultsDashboard results={mockResults} />);\n    \n    expect(screen.getByText('Include spinach in your meals 3-4 times per week')).toBeInTheDocument();\n    expect(screen.getByText('Spend 15-20 minutes in sunlight daily')).toBeInTheDocument();\n  });\n  \n  test('should display expected timeframes', () => {\n    render(<AssessmentResultsDashboard results={mockResults} />);\n    \n    expect(screen.getByText('4-6 weeks')).toBeInTheDocument();\n    expect(screen.getByText('8-12 weeks')).toBeInTheDocument();\n  });\n  \n  test('should display overall nutritional score', () => {\n    render(<AssessmentResultsDashboard results={mockResults} />);\n    \n    expect(screen.getByText('70')).toBeInTheDocument();\n  });\n});\n```\n\n### 5. End-to-End Tests\n- Test the complete assessment flow from questionnaire to results:\n\n```typescript\ndescribe('Nutritional Assessment E2E', () => {\n  test('should complete assessment and show personalized results', async () => {\n    // Mock API responses\n    mockApi.onPost('/api/nutritional-assessment').reply(200, {\n      userId: 'user1',\n      date: new Date().toISOString(),\n      potentialDeficiencies: [\n        {\n          deficiencyId: 'iron-deficiency',\n          probabilityScore: 85,\n          matchedSymptoms: ['fatigue', 'pale-skin'],\n          matchedFactors: ['vegetarian-diet'],\n          personalizedRecommendations: [\n            'Include spinach in your meals 3-4 times per week',\n            'Consider a ferrous sulfate supplement'\n          ],\n          expectedTimeframe: '4-6 weeks'\n        }\n      ],\n      overallNutritionalScore: 70\n    });\n    \n    // Navigate to assessment page\n    render(<NutritionalAssessmentPage />);\n    \n    // Complete the assessment\n    // Step 1: Symptoms\n    fireEvent.click(screen.getByText('Fatigue'));\n    fireEvent.click(screen.getByText('Pale skin'));\n    fireEvent.click(screen.getByText('Next'));\n    \n    // Step 2: Lifestyle Factors\n    fireEvent.click(screen.getByText('Vegetarian diet'));\n    fireEvent.click(screen.getByText('Next'));\n    \n    // Step 3: Medical History\n    fireEvent.click(screen.getByText('Next'));\n    \n    // Step 4: Dietary Habits\n    fireEvent.click(screen.getByText('Submit'));\n    \n    // Wait for results to load\n    await waitFor(() => {\n      expect(screen.getByText('Your Nutritional Assessment Results')).toBeInTheDocument();\n    });\n    \n    // Verify results are displayed\n    expect(screen.getByText('Iron Deficiency')).toBeInTheDocument();\n    expect(screen.getByText('Include spinach in your meals 3-4 times per week')).toBeInTheDocument();\n    expect(screen.getByText('4-6 weeks')).toBeInTheDocument();\n    \n    // Verify quick wins section is present\n    expect(screen.getByText('Quick Wins')).toBeInTheDocument();\n    \n    // Verify educational content is present\n    expect(screen.getByText('Understanding Iron Deficiency')).toBeInTheDocument();\n  });\n});\n```\n\n### 6. Security and Privacy Tests\n- Test the encryption and data protection features:\n\n```typescript\ndescribe('HealthDataEncryptionService', () => {\n  let encryptionService: HealthDataEncryptionService;\n  let mockKeyManagementService: jest.Mocked<KeyManagementService>;\n  \n  beforeEach(() => {\n    mockKeyManagementService = {\n      getEncryptionKey: jest.fn().mockReturnValue(Buffer.from('0123456789abcdef0123456789abcdef'))\n    } as any;\n    \n    encryptionService = new HealthDataEncryptionService(mockKeyManagementService);\n  });\n  \n  test('should encrypt and decrypt health data correctly', () => {\n    const sensitiveData = {\n      userId: 'user1',\n      symptoms: ['fatigue', 'headache'],\n      medicalHistory: ['anemia', 'hypertension']\n    };\n    \n    // Encrypt the data\n    const encrypted = encryptionService.encryptHealthData(sensitiveData);\n    \n    // Verify encrypted data is not readable\n    expect(encrypted).not.toContain('anemia');\n    expect(encrypted).not.toContain('user1');\n    \n    // Decrypt the data\n    const decrypted = encryptionService.decryptHealthData(encrypted);\n    \n    // Verify decrypted data matches original\n    expect(decrypted).toEqual(sensitiveData);\n  });\n  \n  test('should throw error when trying to decrypt with wrong key', () => {\n    const sensitiveData = {\n      userId: 'user1',\n      symptoms: ['fatigue', 'headache']\n    };\n    \n    // Encrypt with original key\n    const encrypted = encryptionService.encryptHealthData(sensitiveData);\n    \n    // Create new service with different key\n    mockKeyManagementService.getEncryptionKey.mockReturnValue(Buffer.from('fedcba9876543210fedcba9876543210'));\n    const newEncryptionService = new HealthDataEncryptionService(mockKeyManagementService);\n    \n    // Attempt to decrypt with wrong key should throw error\n    expect(() => {\n      newEncryptionService.decryptHealthData(encrypted);\n    }).toThrow();\n  });\n});\n```\n\n### 7. Performance Tests\n- Test the assessment algorithm performance with large datasets:\n\n```typescript\ndescribe('NutritionalDeficiencyAssessor Performance', () => {\n  let assessor: NutritionalDeficiencyAssessor;\n  \n  beforeEach(() => {\n    // Setup with real implementations instead of mocks\n    const deficiencyRepo = new DeficiencyRepository();\n    const symptomRepo = new SymptomRepository();\n    const userProfileService = new UserProfileService();\n    const dietaryApproachService = new DietaryApproachService();\n    \n    assessor = new NutritionalDeficiencyAssessor(\n      deficiencyRepo,\n      symptomRepo,\n      userProfileService,\n      dietaryApproachService\n    );\n  });\n  \n  test('should process assessment in under 500ms', async () => {\n    // Generate large test dataset\n    const userId = 'user1';\n    const reportedSymptoms = generateLargeSymptomSet(20); // 20 symptoms\n    const lifestyleFactors = generateLargeLifestyleFactorSet(15); // 15 factors\n    \n    // Measure execution time\n    const startTime = performance.now();\n    await assessor.assessUser(userId, reportedSymptoms, lifestyleFactors);\n    const endTime = performance.now();\n    \n    const executionTime = endTime - startTime;\n    expect(executionTime).toBeLessThan(500); // Should complete in under 500ms\n  });\n  \n  // Helper functions to generate test data\n  function generateLargeSymptomSet(count: number): UserSymptom[] {\n    // Implementation\n  }\n  \n  function generateLargeLifestyleFactorSet(count: number): LifestyleFactor[] {\n    // Implementation\n  }\n});\n```\n\n### 8. Accessibility Tests\n- Test the assessment UI for accessibility compliance:\n\n```typescript\ndescribe('Nutritional Assessment Accessibility', () => {\n  test('assessment wizard should be keyboard navigable', () => {\n    render(<NutritionalAssessmentWizard />);\n    \n    // Focus on first element\n    userEvent.tab();\n    expect(document.activeElement).toHaveTextContent('Fatigue');\n    \n    // Navigate through options with keyboard\n    userEvent.tab();\n    expect(document.activeElement).toHaveTextContent('Headache');\n    \n    userEvent.tab();\n    expect(document.activeElement).toHaveTextContent('Pale skin');\n    \n    // Navigate to next button and press it\n    while (!document.activeElement?.textContent?.includes('Next')) {\n      userEvent.tab();\n    }\n    userEvent.keyboard('{enter}');\n    \n    // Verify moved to next step\n    expect(screen.getByText('Tell us about your lifestyle')).toBeInTheDocument();\n  });\n  \n  test('assessment results should have proper ARIA attributes', () => {\n    render(<AssessmentResultsDashboard results={mockResults} />);\n    \n    // Check for proper headings hierarchy\n    const headings = screen.getAllByRole('heading');\n    expect(headings[0].tagName).toBe('H1'); // Main title should be H1\n    \n    // Check for proper region labels\n    expect(screen.getByRole('region', { name: 'Potential Nutritional Gaps' })).toBeInTheDocument();\n    expect(screen.getByRole('region', { name: 'Your Personalized Nutrition Plan' })).toBeInTheDocument();\n    \n    // Check for proper button labels\n    const buttons = screen.getAllByRole('button');\n    buttons.forEach(button => {\n      expect(button).toHaveAccessibleName();\n    });\n    \n    // Check for proper image alt text\n    const images = screen.getAllByRole('img');\n    images.forEach(img => {\n      expect(img).toHaveAttribute('alt');\n    });\n  });\n});\n```",
        "status": "pending",
        "dependencies": [
          1,
          2,
          4
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Nutritional Deficiency Data Models",
            "description": "Create TypeScript interfaces for nutritional deficiencies, symptoms, and assessment results to establish the foundation for the assessment system.",
            "dependencies": [],
            "details": "Implement the following TypeScript interfaces:\n- NutritionalDeficiency: Define structure for deficiency data including id, name, description, symptoms, risk factors, recommended intake, food sources, and supplement recommendations\n- FoodSource: Structure for food items that address deficiencies, including nutrient content and dietary compatibility\n- SupplementRecommendation: Details about supplement types, dosages, timing, and precautions\n- UserSymptom: Structure for user-reported symptoms with severity and duration\n- LifestyleFactor: Model for lifestyle elements that impact nutritional status\n- AssessmentResult: Structure for storing assessment outcomes\n- PotentialDeficiency: Model for identified potential deficiencies with probability scores and recommendations\n\nCreate a comprehensive database of at least 5 common nutritional deficiencies (Iron, B12, D3, Magnesium, and Omega-3) with detailed information about symptoms, causes, food sources, and supplement recommendations.",
            "status": "pending",
            "testStrategy": "- Write unit tests to validate the structure of each interface\n- Create test fixtures with sample data for each deficiency\n- Verify that the data models can properly represent all required information\n- Test serialization/deserialization of the models to ensure they work with API endpoints\n- Validate that the deficiency database contains complete information for all required nutrients"
          },
          {
            "id": 2,
            "title": "Develop Assessment Algorithm",
            "description": "Implement a rule-based expert system that evaluates user symptoms and lifestyle factors to identify potential nutritional deficiencies with probability scores.",
            "dependencies": [
              "6.1"
            ],
            "details": "Implement the NutritionalDeficiencyAssessor class with the following functionality:\n- Constructor that accepts repositories for deficiencies, symptoms, user profiles, and dietary approaches\n- assessUser method that evaluates reported symptoms and lifestyle factors\n- Helper methods for matching symptoms to deficiencies\n- Algorithm for calculating probability scores based on symptom severity, duration, and risk factors\n- Logic for generating personalized recommendations based on user profile and dietary approach\n- Methods for estimating improvement timeframes\n- Overall nutritional score calculation\n\nImplement the PersonalizedRecommendationEngine class to generate tailored advice based on:\n- User dietary preferences and restrictions\n- Compatible food sources for identified deficiencies\n- Appropriate supplement recommendations\n- Lifestyle modifications\n- Quick-win suggestions",
            "status": "pending",
            "testStrategy": "- Write unit tests for each component of the assessment algorithm\n- Test with various combinations of symptoms and lifestyle factors\n- Verify that probability scores are calculated correctly\n- Test edge cases (no symptoms, many symptoms, conflicting factors)\n- Validate that recommendations are appropriate for the identified deficiencies\n- Ensure the algorithm correctly prioritizes deficiencies based on probability scores\n- Test that dietary restrictions are properly considered in recommendations"
          },
          {
            "id": 3,
            "title": "Create Assessment Questionnaire UI",
            "description": "Develop a multi-step questionnaire interface to collect user symptoms, lifestyle factors, medical history, and dietary habits for nutritional assessment.",
            "dependencies": [
              "6.1"
            ],
            "details": "Implement a React-based assessment wizard with the following features:\n- Multi-step form with progress indicator\n- Step 1: Symptom assessment with severity and duration inputs\n- Step 2: Lifestyle factors collection (diet, exercise, sleep, stress, medical)\n- Step 3: Medical history relevant to nutritional status\n- Step 4: Detailed dietary habits questionnaire\n- State management for collecting and validating user inputs\n- Responsive design for mobile and desktop use\n- Clear instructions and educational tooltips\n- Ability to save progress and return later\n- Final review step before submission\n\nEnsure the UI is accessible and provides clear guidance on how to accurately report symptoms and lifestyle factors.",
            "status": "pending",
            "testStrategy": "- Write unit tests for each component of the questionnaire\n- Implement integration tests for the complete form flow\n- Test form validation logic\n- Verify that the state is properly maintained between steps\n- Test accessibility compliance\n- Conduct usability testing with representative users\n- Test on multiple devices and screen sizes\n- Verify that the collected data is properly formatted for the assessment algorithm"
          },
          {
            "id": 4,
            "title": "Implement Results Visualization Dashboard",
            "description": "Create a comprehensive dashboard to display assessment results, including potential deficiencies, personalized recommendations, and educational content.",
            "dependencies": [
              "6.2",
              "6.3"
            ],
            "details": "Develop a React-based results dashboard with the following components:\n- OverallScoreCard: Visual representation of nutritional health score\n- DeficiencyCard: Detailed cards for each identified potential deficiency\n- QuickWinsSection: Easy-to-implement recommendations\n- TimeframeExpectations: Expected timeline for improvement\n- ActionPlanTimeline: Structured plan for addressing deficiencies\n- EducationalContent: Information about each identified deficiency\n\nImplement data visualization components:\n- Probability score gauges for each deficiency\n- Symptom-deficiency correlation charts\n- Nutrient intake vs. recommended intake comparisons\n- Progress tracking visualizations\n\nEnsure the dashboard is actionable, educational, and motivating for users to follow through with recommendations.",
            "status": "pending",
            "testStrategy": "- Write unit tests for each dashboard component\n- Test rendering with various assessment result data\n- Verify that visualizations accurately represent the data\n- Test interactive elements and state management\n- Conduct usability testing to ensure information is understandable\n- Test accessibility compliance\n- Verify that recommendations are displayed in order of priority\n- Test responsive behavior on different screen sizes"
          },
          {
            "id": 5,
            "title": "Develop Progress Tracking and Integration",
            "description": "Implement a system to track user progress over time and integrate the nutritional assessment with the meal planning system to address identified deficiencies.",
            "dependencies": [
              "6.4"
            ],
            "details": "Implement the DeficiencyProgressTracker class with the following functionality:\n- Methods to record progress entries with symptom severity, supplement adherence, and overall feeling\n- Functions to generate progress reports over time periods\n- Algorithms to calculate symptom improvements and adherence metrics\n- Insight generation based on progress data\n\nImplement the NutrientFocusedMealPlanAdapter class to integrate with the meal planning system:\n- Methods to translate deficiency assessment results into meal plan parameters\n- Logic to prioritize food sources that address identified deficiencies\n- Integration with the existing MealPlanGenerator\n\nImplement security measures for handling sensitive health data:\n- Data encryption for health information\n- Proper authentication and authorization\n- HIPAA-compliant data handling practices\n- Secure API endpoints for assessment data",
            "status": "pending",
            "testStrategy": "- Write unit tests for the progress tracking components\n- Test the calculation of improvement metrics\n- Verify that progress insights are meaningful\n- Test the integration with the meal planning system\n- Verify that generated meal plans properly address identified deficiencies\n- Test security measures including encryption and decryption\n- Conduct integration tests for the complete workflow from assessment to meal planning\n- Verify that progress data is properly stored and retrieved"
          }
        ]
      },
      {
        "id": 7,
        "title": "Anti-Theft and Premium User Experience System",
        "description": "Implement a secure content protection system with premium user experience features including preview mode, commitment gates, time-limited access, progressive disclosure, and social proof elements to prevent unauthorized access while creating an exclusive feel.",
        "details": "## Implementation Details\n\n### 1. Content Protection Architecture\n- Design a layered content protection system using TypeScript and React\n- Implement server-side validation for all protected content requests\n- Create middleware to verify authentication and authorization\n\n```typescript\n// Content protection middleware\nconst protectContent = async (req: Request, res: Response, next: NextFunction) => {\n  const { userId, contentId } = req;\n  const accessLevel = await userService.getUserAccessLevel(userId);\n  const contentAccess = await contentService.getContentAccessRequirements(contentId);\n  \n  if (!accessLevel.meetsRequirements(contentAccess)) {\n    return res.status(403).json({ error: 'Premium content access required' });\n  }\n  \n  next();\n};\n```\n\n### 2. Preview Mode Implementation\n- Create a `ContentPreviewService` to manage limited content access\n- Implement content blurring/truncation for non-premium users\n- Add clear visual indicators for premium vs. preview content\n\n```typescript\ninterface PreviewConfig {\n  previewPercentage: number; // Percentage of content to show (e.g., 30%)\n  blurredSections: boolean;\n  callToActionText: string;\n}\n\nclass ContentPreviewService {\n  getPreviewContent(fullContent: MealPlan, config: PreviewConfig): PreviewMealPlan {\n    return {\n      ...fullContent,\n      weeks: fullContent.weeks.slice(0, Math.ceil(fullContent.weeks.length * config.previewPercentage / 100)),\n      isPreview: true,\n      upgradeMessage: config.callToActionText\n    };\n  }\n}\n```\n\n### 3. Commitment Gates\n- Implement a multi-step payment flow with clear value proposition at each step\n- Create a `PaymentGateService` to manage access control\n- Design compelling upgrade screens highlighting exclusive benefits\n\n```typescript\ninterface CommitmentGate {\n  id: string;\n  title: string;\n  description: string;\n  requiredAction: 'payment' | 'email' | 'survey';\n  benefitsUnlocked: string[];\n  displayCondition: (user: User) => boolean;\n}\n\nclass CommitmentGateService {\n  private gates: CommitmentGate[];\n  \n  constructor(gates: CommitmentGate[]) {\n    this.gates = gates;\n  }\n  \n  getNextGateForUser(user: User): CommitmentGate | null {\n    return this.gates.find(gate => gate.displayCondition(user)) || null;\n  }\n  \n  recordGateCompletion(userId: string, gateId: string): Promise<void> {\n    // Record that user has passed this gate\n  }\n}\n```\n\n### 4. Time-Limited Access Control\n- Implement token-based access with expiration times\n- Create a `TimeBasedAccessService` to manage content availability\n- Add countdown timers for expiring content to create urgency\n\n```typescript\ninterface AccessToken {\n  userId: string;\n  contentId: string;\n  expiresAt: Date;\n  accessLevel: 'preview' | 'full' | 'temporary';\n}\n\nclass TimeBasedAccessService {\n  generateAccessToken(userId: string, contentId: string, durationHours: number): AccessToken {\n    const expiresAt = new Date();\n    expiresAt.setHours(expiresAt.getHours() + durationHours);\n    \n    return {\n      userId,\n      contentId,\n      expiresAt,\n      accessLevel: durationHours < 24 ? 'temporary' : 'full'\n    };\n  }\n  \n  validateToken(token: AccessToken): boolean {\n    return new Date() < token.expiresAt;\n  }\n  \n  getRemainingTime(token: AccessToken): number {\n    return Math.max(0, token.expiresAt.getTime() - new Date().getTime());\n  }\n}\n```\n\n### 5. Progressive Disclosure System\n- Design a content unlocking system based on user engagement\n- Implement a `ProgressiveDisclosureService` to manage content visibility\n- Create visual indicators for locked/unlocked content\n\n```typescript\ninterface DisclosureStage {\n  id: string;\n  name: string;\n  requiredActions: UserAction[];\n  contentUnlocked: string[];\n}\n\nclass ProgressiveDisclosureService {\n  private stages: DisclosureStage[];\n  \n  constructor(stages: DisclosureStage[]) {\n    this.stages = stages;\n  }\n  \n  getUserStage(userId: string): Promise<DisclosureStage> {\n    // Determine user's current stage based on completed actions\n  }\n  \n  isContentUnlocked(userId: string, contentId: string): Promise<boolean> {\n    // Check if specific content is unlocked for this user\n  }\n  \n  getNextRequiredActions(userId: string): Promise<UserAction[]> {\n    // Get actions user needs to complete to advance\n  }\n}\n```\n\n### 6. Social Proof Elements\n- Implement testimonial and user count components\n- Create a system to display real-time purchase notifications\n- Add progress tracking compared to other users\n\n```typescript\ninterface SocialProofElement {\n  type: 'testimonial' | 'userCount' | 'recentPurchase' | 'popularity';\n  content: string;\n  displayCondition: (user: User) => boolean;\n  position: 'paymentPage' | 'previewMode' | 'dashboard';\n}\n\nclass SocialProofService {\n  getRelevantProofElements(user: User, context: string): SocialProofElement[] {\n    // Return social proof elements relevant to this user and context\n  }\n  \n  recordConversionInfluence(userId: string, elementId: string): void {\n    // Track which social proof elements influence conversions\n  }\n}\n```\n\n### 7. Security Measures\n- Implement watermarking for PDF content with user identifiers\n- Add server-side validation for all content access requests\n- Create an audit logging system for content access attempts\n\n```typescript\ninterface ContentSecurityConfig {\n  watermarkEnabled: boolean;\n  accessLoggingEnabled: boolean;\n  rateLimitRequests: number;\n  rateLimitTimeWindow: number; // in seconds\n}\n\nclass ContentSecurityService {\n  applyWatermark(content: Buffer, userId: string): Buffer {\n    // Add user-specific watermark to content\n  }\n  \n  logAccessAttempt(userId: string, contentId: string, success: boolean): void {\n    // Log access attempt for security monitoring\n  }\n  \n  detectSuspiciousActivity(userId: string): Promise<boolean> {\n    // Analyze access patterns for potential abuse\n  }\n}\n```\n\n### 8. Integration with Existing Systems\n- Connect with the PDF Generation System (Task 5) to apply security features\n- Integrate with the Meal Plan Generation Algorithm (Task 4) to create preview versions\n- Ensure compatibility with the User Wizard Flow (Task 3) for premium upsells",
        "testStrategy": "## Test Strategy\n\n### 1. Unit Tests\n- Test each service component independently:\n\n```typescript\ndescribe('ContentPreviewService', () => {\n  const service = new ContentPreviewService();\n  \n  test('should correctly limit preview content', () => {\n    const fullMealPlan = createTestMealPlan(6); // 6 weeks\n    const preview = service.getPreviewContent(fullMealPlan, { \n      previewPercentage: 30, \n      blurredSections: true,\n      callToActionText: 'Upgrade for full access'\n    });\n    \n    expect(preview.weeks.length).toBe(2); // 30% of 6 weeks = ~2 weeks\n    expect(preview.isPreview).toBe(true);\n    expect(preview.upgradeMessage).toBe('Upgrade for full access');\n  });\n});\n\ndescribe('TimeBasedAccessService', () => {\n  const service = new TimeBasedAccessService();\n  \n  test('should generate valid access tokens', () => {\n    const token = service.generateAccessToken('user123', 'content456', 24);\n    \n    expect(token.userId).toBe('user123');\n    expect(token.contentId).toBe('content456');\n    expect(token.accessLevel).toBe('full');\n    \n    // Token should be valid now\n    expect(service.validateToken(token)).toBe(true);\n    \n    // Mock future date to test expiration\n    jest.spyOn(global, 'Date').mockImplementation(() => {\n      return new Date(Date.now() + 25 * 60 * 60 * 1000); // 25 hours later\n    });\n    \n    expect(service.validateToken(token)).toBe(false);\n  });\n});\n```\n\n### 2. Integration Tests\n- Test the interaction between content protection and user authentication:\n\n```typescript\ndescribe('Protected Content Access', () => {\n  let app: Express;\n  let authService: AuthService;\n  let contentService: ContentService;\n  \n  beforeAll(() => {\n    app = createTestApp();\n    authService = app.get(AuthService);\n    contentService = app.get(ContentService);\n  });\n  \n  test('should deny access to premium content for non-premium users', async () => {\n    const user = await createTestUser({ premium: false });\n    const token = authService.generateToken(user);\n    \n    const response = await request(app)\n      .get('/api/meal-plans/premium/123')\n      .set('Authorization', `Bearer ${token}`);\n    \n    expect(response.status).toBe(403);\n    expect(response.body.error).toBe('Premium content access required');\n  });\n  \n  test('should grant access to premium content for premium users', async () => {\n    const user = await createTestUser({ premium: true });\n    const token = authService.generateToken(user);\n    \n    const response = await request(app)\n      .get('/api/meal-plans/premium/123')\n      .set('Authorization', `Bearer ${token}`);\n    \n    expect(response.status).toBe(200);\n    expect(response.body.isPreview).toBe(false);\n  });\n});\n```\n\n### 3. Security Testing\n- Implement penetration testing for content protection:\n\n```typescript\ndescribe('Content Security', () => {\n  test('should detect token tampering', async () => {\n    const validToken = authService.generateToken({ id: 'user123', premium: false });\n    const tamperedToken = validToken.slice(0, -5) + 'XXXXX'; // Tamper with signature\n    \n    const response = await request(app)\n      .get('/api/meal-plans/premium/123')\n      .set('Authorization', `Bearer ${tamperedToken}`);\n    \n    expect(response.status).toBe(401);\n  });\n  \n  test('should prevent URL manipulation to access protected content', async () => {\n    const user = await createTestUser({ premium: false });\n    const token = authService.generateToken(user);\n    \n    // Try to access protected content by changing URL\n    const response = await request(app)\n      .get('/api/meal-plans/123/full-content')\n      .set('Authorization', `Bearer ${token}`);\n    \n    expect(response.status).toBe(403);\n  });\n});\n```\n\n### 4. User Experience Testing\n- Test the premium user experience flow:\n\n```typescript\ndescribe('Premium User Experience', () => {\n  test('should show appropriate commitment gates based on user status', async () => {\n    const user = await createTestUser({ completedSteps: ['profile', 'goals'] });\n    const gateService = new CommitmentGateService([...testGates]);\n    \n    const nextGate = await gateService.getNextGateForUser(user);\n    \n    expect(nextGate).not.toBeNull();\n    expect(nextGate.id).toBe('payment-gate-1');\n    expect(nextGate.requiredAction).toBe('payment');\n  });\n  \n  test('should correctly apply progressive disclosure', async () => {\n    const user = await createTestUser({ completedActions: ['login', 'profile'] });\n    const disclosureService = new ProgressiveDisclosureService([...testStages]);\n    \n    const userStage = await disclosureService.getUserStage(user.id);\n    const isRecipesUnlocked = await disclosureService.isContentUnlocked(user.id, 'recipes');\n    const nextActions = await disclosureService.getNextRequiredActions(user.id);\n    \n    expect(userStage.id).toBe('stage-1');\n    expect(isRecipesUnlocked).toBe(false);\n    expect(nextActions).toContain('complete-survey');\n  });\n});\n```\n\n### 5. Performance Testing\n- Test system performance under load:\n\n```typescript\ndescribe('Performance Tests', () => {\n  test('should handle concurrent access requests efficiently', async () => {\n    const users = await createTestUsers(100);\n    const contentId = 'premium-meal-plan-123';\n    \n    const startTime = Date.now();\n    \n    await Promise.all(users.map(user => \n      contentService.checkAccess(user.id, contentId)\n    ));\n    \n    const endTime = Date.now();\n    const duration = endTime - startTime;\n    \n    // Access checks should be fast (adjust threshold as needed)\n    expect(duration).toBeLessThan(1000);\n  });\n});",
        "status": "pending",
        "dependencies": [
          1,
          3,
          4,
          5
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Content Protection Architecture",
            "description": "Design and implement a layered content protection system with server-side validation and authentication middleware",
            "dependencies": [],
            "details": "Create a robust content protection architecture using TypeScript and React. Implement server-side validation for all protected content requests to prevent unauthorized access. Develop middleware to verify user authentication and authorization before serving premium content. Design the system to handle different access levels and content requirements.",
            "status": "pending",
            "testStrategy": "Write unit tests for the authentication middleware to verify it correctly identifies and blocks unauthorized access attempts. Create integration tests to ensure the protection system works across the full request lifecycle. Test edge cases like expired tokens and different user permission levels."
          },
          {
            "id": 2,
            "title": "Preview Mode Implementation",
            "description": "Create a system for displaying limited content previews to non-premium users with clear upgrade paths",
            "dependencies": [
              "7.1"
            ],
            "details": "Develop a ContentPreviewService that manages limited content access for non-premium users. Implement content blurring/truncation techniques to show partial content. Add clear visual indicators distinguishing premium from preview content. Design compelling call-to-action elements that encourage users to upgrade for full access.",
            "status": "pending",
            "testStrategy": "Test the preview generation logic to ensure it correctly limits content based on configuration parameters. Verify that preview indicators are properly displayed in the UI. Test that preview content maintains data integrity while limiting access to premium features."
          },
          {
            "id": 3,
            "title": "Commitment Gates and Time-Limited Access",
            "description": "Implement multi-step payment flow with commitment gates and time-based access control for premium content",
            "dependencies": [
              "7.1",
              "7.2"
            ],
            "details": "Create a PaymentGateService to manage multi-step commitment gates with clear value propositions at each step. Design compelling upgrade screens highlighting exclusive benefits. Implement token-based access with expiration times using a TimeBasedAccessService. Add countdown timers for expiring content to create urgency and drive conversions.",
            "status": "pending",
            "testStrategy": "Test the commitment gate flow to ensure users are properly guided through each step. Verify that access tokens are correctly generated with appropriate expiration times. Test the validation logic for expired tokens and ensure countdown timers accurately reflect remaining access time."
          },
          {
            "id": 4,
            "title": "Progressive Disclosure System",
            "description": "Design and implement a content unlocking system based on user engagement with visual indicators",
            "dependencies": [
              "7.1"
            ],
            "details": "Develop a ProgressiveDisclosureService that manages content visibility based on user engagement levels. Create a system of disclosure stages with required actions to unlock additional content. Implement visual indicators for locked/unlocked content to guide users through the engagement journey. Design the system to encourage continued interaction with the platform.",
            "status": "pending",
            "testStrategy": "Test that content is correctly locked/unlocked based on user actions. Verify that the system accurately tracks user progress through disclosure stages. Test the visual indicators to ensure they clearly communicate content availability status to users."
          },
          {
            "id": 5,
            "title": "Social Proof and Security Measures",
            "description": "Implement social proof elements and content security features including watermarking and access logging",
            "dependencies": [
              "7.1",
              "7.3",
              "7.4"
            ],
            "details": "Create a SocialProofService to display testimonials, user counts, and real-time purchase notifications. Implement watermarking for PDF content with user identifiers to discourage sharing. Add server-side validation for all content access requests and develop an audit logging system for content access attempts. Create a ContentSecurityService to detect suspicious activity patterns.",
            "status": "pending",
            "testStrategy": "Test that social proof elements are displayed appropriately based on user context. Verify that watermarking correctly applies unique identifiers to generated content. Test the access logging system to ensure it captures all relevant security events. Validate that the suspicious activity detection correctly identifies potential abuse patterns."
          }
        ]
      },
      {
        "id": 8,
        "title": "Shopping List Generation System",
        "description": "Develop a system that automatically generates weekly shopping lists from the 6-week meal plan with smart categorization, quantity optimization to reduce waste, and cost estimation features.",
        "details": "## Implementation Details\n\n### 1. Data Model Design\n- Create TypeScript interfaces for shopping list items and categories:\n\n```typescript\ninterface ShoppingListItem {\n  id: string;\n  name: string;\n  quantity: number;\n  unit: string;\n  category: ItemCategory;\n  estimatedPrice: number;\n  recipeIds: string[]; // tracks which recipes require this item\n}\n\nenum ItemCategory {\n  PRODUCE = 'produce',\n  PROTEINS = 'proteins',\n  DAIRY = 'dairy',\n  PANTRY = 'pantry',\n  FROZEN = 'frozen',\n  SPICES = 'spices',\n  OTHER = 'other'\n}\n\ninterface ShoppingList {\n  id: string;\n  userId: string;\n  weekNumber: number; // 1-6 corresponding to meal plan week\n  items: ShoppingListItem[];\n  totalEstimatedCost: number;\n  createdAt: Date;\n  updatedAt: Date;\n}\n```\n\n### 2. Shopping List Generator Service\n- Implement a service to extract ingredients from meal plans and consolidate them:\n\n```typescript\nclass ShoppingListGeneratorService {\n  constructor(\n    private mealPlanService: MealPlanService,\n    private ingredientService: IngredientService,\n    private priceEstimationService: PriceEstimationService\n  ) {}\n\n  async generateWeeklyShoppingList(userId: string, weekNumber: number): Promise<ShoppingList> {\n    // Get meal plan for the specified week\n    const mealPlan = await this.mealPlanService.getMealPlanForWeek(userId, weekNumber);\n    \n    // Extract all ingredients from recipes in the meal plan\n    const ingredientMap = new Map<string, ShoppingListItem>();\n    \n    for (const day of mealPlan.days) {\n      for (const meal of day.meals) {\n        const recipe = meal.recipe;\n        for (const ingredient of recipe.ingredients) {\n          this.addOrUpdateIngredient(ingredientMap, ingredient, recipe.id);\n        }\n      }\n    }\n    \n    // Convert map to array and categorize items\n    const items = Array.from(ingredientMap.values());\n    this.categorizeItems(items);\n    \n    // Calculate total estimated cost\n    const totalEstimatedCost = items.reduce((sum, item) => sum + item.estimatedPrice, 0);\n    \n    return {\n      id: uuidv4(),\n      userId,\n      weekNumber,\n      items,\n      totalEstimatedCost,\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n  }\n\n  private addOrUpdateIngredient(\n    ingredientMap: Map<string, ShoppingListItem>,\n    ingredient: RecipeIngredient,\n    recipeId: string\n  ): void {\n    const normalizedName = this.normalizeIngredientName(ingredient.name);\n    \n    if (ingredientMap.has(normalizedName)) {\n      // Update existing ingredient\n      const existingItem = ingredientMap.get(normalizedName)!;\n      existingItem.quantity += this.convertToStandardUnit(ingredient.quantity, ingredient.unit, existingItem.unit);\n      existingItem.recipeIds.push(recipeId);\n      existingItem.estimatedPrice = this.priceEstimationService.estimatePrice(existingItem.name, existingItem.quantity, existingItem.unit);\n    } else {\n      // Add new ingredient\n      const category = this.ingredientService.getCategoryForIngredient(normalizedName);\n      const standardUnit = this.ingredientService.getStandardUnitForIngredient(normalizedName);\n      const quantity = this.convertToStandardUnit(ingredient.quantity, ingredient.unit, standardUnit);\n      \n      ingredientMap.set(normalizedName, {\n        id: uuidv4(),\n        name: normalizedName,\n        quantity,\n        unit: standardUnit,\n        category,\n        estimatedPrice: this.priceEstimationService.estimatePrice(normalizedName, quantity, standardUnit),\n        recipeIds: [recipeId]\n      });\n    }\n  }\n\n  private normalizeIngredientName(name: string): string {\n    // Normalize ingredient names (e.g., \"Red Bell Pepper\" and \"Bell Pepper, Red\" should be the same)\n    return name.toLowerCase().trim();\n  }\n\n  private convertToStandardUnit(quantity: number, fromUnit: string, toUnit: string): number {\n    // Convert between units (e.g., tbsp to ml, oz to g)\n    // This would use a conversion service or library\n    return this.ingredientService.convertUnits(quantity, fromUnit, toUnit);\n  }\n\n  private categorizeItems(items: ShoppingListItem[]): void {\n    // Categorize items based on ingredient database\n    for (const item of items) {\n      item.category = this.ingredientService.getCategoryForIngredient(item.name);\n    }\n  }\n}\n```\n\n### 3. Quantity Optimization\n- Implement smart quantity optimization to reduce food waste:\n\n```typescript\nclass QuantityOptimizer {\n  private packagingSizes: Map<string, number[]> = new Map(); // Maps ingredient to common packaging sizes\n  \n  constructor(private ingredientService: IngredientService) {\n    // Initialize with common packaging sizes\n    this.loadPackagingSizes();\n  }\n  \n  optimizeQuantities(shoppingList: ShoppingList): ShoppingList {\n    const optimizedItems = shoppingList.items.map(item => {\n      // Get standard packaging sizes for this ingredient\n      const sizes = this.packagingSizes.get(item.name) || this.getDefaultSizes(item.unit);\n      \n      // Find the optimal packaging size\n      const optimizedQuantity = this.findOptimalQuantity(item.quantity, sizes);\n      \n      // Update the price based on the new quantity\n      const optimizedPrice = (item.estimatedPrice / item.quantity) * optimizedQuantity;\n      \n      return {\n        ...item,\n        quantity: optimizedQuantity,\n        estimatedPrice: optimizedPrice,\n        notes: optimizedQuantity > item.quantity ? \n          `Rounded up to reduce waste. Extra: ${(optimizedQuantity - item.quantity).toFixed(2)} ${item.unit}` : \n          undefined\n      };\n    });\n    \n    // Recalculate total cost\n    const totalEstimatedCost = optimizedItems.reduce((sum, item) => sum + item.estimatedPrice, 0);\n    \n    return {\n      ...shoppingList,\n      items: optimizedItems,\n      totalEstimatedCost,\n      updatedAt: new Date()\n    };\n  }\n  \n  private findOptimalQuantity(required: number, availableSizes: number[]): number {\n    // Find the smallest packaging size that meets or exceeds the required quantity\n    const sortedSizes = [...availableSizes].sort((a, b) => a - b);\n    \n    for (const size of sortedSizes) {\n      if (size >= required) {\n        return size;\n      }\n    }\n    \n    // If no single package is large enough, calculate multiple packages\n    const largestSize = sortedSizes[sortedSizes.length - 1];\n    const numPackages = Math.ceil(required / largestSize);\n    return largestSize * numPackages;\n  }\n  \n  private getDefaultSizes(unit: string): number[] {\n    // Return default packaging sizes based on unit\n    switch (unit.toLowerCase()) {\n      case 'g':\n        return [100, 250, 500, 1000];\n      case 'ml':\n        return [100, 250, 500, 1000];\n      case 'pcs':\n        return [1, 2, 3, 4, 6, 8, 12];\n      default:\n        return [0.25, 0.5, 1, 2, 5, 10];\n    }\n  }\n  \n  private loadPackagingSizes(): void {\n    // Load common packaging sizes from ingredient service or database\n    this.packagingSizes = this.ingredientService.getCommonPackagingSizes();\n  }\n}\n```\n\n### 4. Price Estimation Service\n- Create a service to estimate costs of shopping list items:\n\n```typescript\nclass PriceEstimationService {\n  private priceDatabase: Map<string, number> = new Map(); // Maps ingredient to price per unit\n  \n  constructor() {\n    // Initialize with average prices\n    this.loadPriceDatabase();\n  }\n  \n  estimatePrice(ingredient: string, quantity: number, unit: string): number {\n    const normalizedName = ingredient.toLowerCase().trim();\n    const pricePerUnit = this.priceDatabase.get(normalizedName) || this.getEstimatedPricePerUnit(normalizedName, unit);\n    \n    return pricePerUnit * quantity;\n  }\n  \n  private getEstimatedPricePerUnit(ingredient: string, unit: string): number {\n    // Fallback logic for ingredients not in the database\n    // This could use category averages or other heuristics\n    const categoryMap = {\n      'produce': 0.15, // DKK per gram\n      'proteins': 0.25,\n      'dairy': 0.10,\n      'pantry': 0.05,\n      'frozen': 0.12,\n      'spices': 0.50,\n      'other': 0.20\n    };\n    \n    // Determine category\n    let category = 'other';\n    for (const [cat, regex] of this.categoryPatterns.entries()) {\n      if (regex.test(ingredient)) {\n        category = cat;\n        break;\n      }\n    }\n    \n    return categoryMap[category] || 0.20;\n  }\n  \n  private get categoryPatterns(): Map<string, RegExp> {\n    return new Map([\n      ['produce', /apple|banana|carrot|lettuce|spinach|onion|potato|tomato|cucumber/i],\n      ['proteins', /chicken|beef|pork|fish|tofu|beans|lentils|eggs/i],\n      ['dairy', /milk|cheese|yogurt|cream|butter/i],\n      ['pantry', /flour|rice|pasta|oil|vinegar|canned|sauce/i],\n      ['frozen', /frozen/i],\n      ['spices', /spice|herb|salt|pepper|cinnamon|oregano|basil/i]\n    ]);\n  }\n  \n  private loadPriceDatabase(): void {\n    // In a real implementation, this would load from a database or API\n    // For now, we'll use some sample data\n    this.priceDatabase = new Map([\n      ['chicken breast', 0.12], // DKK per gram\n      ['ground beef', 0.10],\n      ['salmon fillet', 0.25],\n      ['rice', 0.02],\n      ['pasta', 0.015],\n      ['olive oil', 0.08],\n      ['milk', 0.01],\n      ['eggs', 2.5], // per egg\n      ['apple', 3.5], // per apple\n      ['banana', 2.5], // per banana\n      ['spinach', 0.05],\n      ['tomato', 4.0], // per tomato\n      ['onion', 3.0], // per onion\n      ['garlic', 1.0], // per clove\n      ['bread', 25.0] // per loaf\n    ]);\n  }\n}\n```\n\n### 5. Shopping List API Endpoints\n- Create RESTful API endpoints for shopping list operations:\n\n```typescript\n// Express route handlers\nrouter.get('/api/shopping-lists/:userId/week/:weekNumber', async (req, res) => {\n  try {\n    const { userId, weekNumber } = req.params;\n    const shoppingListService = new ShoppingListGeneratorService(\n      new MealPlanService(),\n      new IngredientService(),\n      new PriceEstimationService()\n    );\n    \n    const shoppingList = await shoppingListService.generateWeeklyShoppingList(userId, parseInt(weekNumber));\n    \n    // Apply quantity optimization\n    const quantityOptimizer = new QuantityOptimizer(new IngredientService());\n    const optimizedList = quantityOptimizer.optimizeQuantities(shoppingList);\n    \n    res.json(optimizedList);\n  } catch (error) {\n    console.error('Error generating shopping list:', error);\n    res.status(500).json({ error: 'Failed to generate shopping list' });\n  }\n});\n\nrouter.get('/api/shopping-lists/:userId/full-plan', async (req, res) => {\n  try {\n    const { userId } = req.params;\n    const shoppingListService = new ShoppingListGeneratorService(\n      new MealPlanService(),\n      new IngredientService(),\n      new PriceEstimationService()\n    );\n    \n    // Generate shopping lists for all 6 weeks\n    const shoppingLists = [];\n    for (let week = 1; week <= 6; week++) {\n      const list = await shoppingListService.generateWeeklyShoppingList(userId, week);\n      shoppingLists.push(list);\n    }\n    \n    res.json(shoppingLists);\n  } catch (error) {\n    console.error('Error generating full plan shopping lists:', error);\n    res.status(500).json({ error: 'Failed to generate full plan shopping lists' });\n  }\n});\n```\n\n### 6. Frontend Components\n- Create React components for displaying and interacting with shopping lists:\n\n```tsx\n// ShoppingListView.tsx\nimport React, { useState, useEffect } from 'react';\nimport { ShoppingList, ItemCategory } from '../types/shoppingList';\n\ninterface ShoppingListViewProps {\n  userId: string;\n  weekNumber: number;\n}\n\nexport const ShoppingListView: React.FC<ShoppingListViewProps> = ({ userId, weekNumber }) => {\n  const [shoppingList, setShoppingList] = useState<ShoppingList | null>(null);\n  const [loading, setLoading] = useState<boolean>(true);\n  const [error, setError] = useState<string | null>(null);\n  \n  useEffect(() => {\n    const fetchShoppingList = async () => {\n      try {\n        setLoading(true);\n        const response = await fetch(`/api/shopping-lists/${userId}/week/${weekNumber}`);\n        \n        if (!response.ok) {\n          throw new Error('Failed to fetch shopping list');\n        }\n        \n        const data = await response.json();\n        setShoppingList(data);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    fetchShoppingList();\n  }, [userId, weekNumber]);\n  \n  if (loading) return <div>Loading shopping list...</div>;\n  if (error) return <div>Error: {error}</div>;\n  if (!shoppingList) return <div>No shopping list available</div>;\n  \n  // Group items by category\n  const itemsByCategory = shoppingList.items.reduce((acc, item) => {\n    if (!acc[item.category]) {\n      acc[item.category] = [];\n    }\n    acc[item.category].push(item);\n    return acc;\n  }, {} as Record<ItemCategory, ShoppingListItem[]>);\n  \n  return (\n    <div className=\"shopping-list\">\n      <h2>Shopping List for Week {weekNumber}</h2>\n      <div className=\"total-cost\">\n        Estimated Total: {shoppingList.totalEstimatedCost.toFixed(2)} DKK\n      </div>\n      \n      {Object.entries(itemsByCategory).map(([category, items]) => (\n        <div key={category} className=\"category-section\">\n          <h3>{category.charAt(0).toUpperCase() + category.slice(1)}</h3>\n          <ul>\n            {items.map(item => (\n              <li key={item.id} className=\"shopping-item\">\n                <span className=\"item-name\">{item.name}</span>\n                <span className=\"item-quantity\">{item.quantity} {item.unit}</span>\n                <span className=\"item-price\">{item.estimatedPrice.toFixed(2)} DKK</span>\n                {item.notes && <span className=\"item-notes\">{item.notes}</span>}\n              </li>\n            ))}\n          </ul>\n        </div>\n      ))}\n      \n      <div className=\"shopping-list-actions\">\n        <button onClick={() => window.print()}>Print List</button>\n        <button>Export as PDF</button>\n        <button>Send to Email</button>\n      </div>\n    </div>\n  );\n};\n```\n\n### 7. Foundation for Future API Integration\n- Create an abstract interface for future shopping center API integration:\n\n```typescript\ninterface ShoppingCenterAPI {\n  getProductPrice(productName: string, quantity: number, unit: string): Promise<number>;\n  getProductOffers(productName: string): Promise<ProductOffer[]>;\n  findAlternatives(productName: string): Promise<Product[]>;\n}\n\ninterface ProductOffer {\n  productName: string;\n  regularPrice: number;\n  offerPrice: number;\n  offerValidUntil: Date;\n  storeName: string;\n  storeLocation: string;\n}\n\ninterface Product {\n  name: string;\n  brand: string;\n  price: number;\n  unit: string;\n  packageSize: number;\n  category: string;\n  imageUrl?: string;\n}\n\n// Placeholder implementation for future integration\nclass DanishShoppingCenterAPIClient implements ShoppingCenterAPI {\n  constructor(private apiKey: string, private baseUrl: string) {}\n  \n  async getProductPrice(productName: string, quantity: number, unit: string): Promise<number> {\n    // This will be implemented when API integration is ready\n    console.log(`Future implementation: Get price for ${quantity} ${unit} of ${productName}`);\n    return 0;\n  }\n  \n  async getProductOffers(productName: string): Promise<ProductOffer[]> {\n    // This will be implemented when API integration is ready\n    console.log(`Future implementation: Get offers for ${productName}`);\n    return [];\n  }\n  \n  async findAlternatives(productName: string): Promise<Product[]> {\n    // This will be implemented when API integration is ready\n    console.log(`Future implementation: Find alternatives for ${productName}`);\n    return [];\n  }\n}\n```\n\n### 8. Database Schema\n- Design MongoDB schema for shopping lists:\n\n```typescript\n// MongoDB schema using Mongoose\nimport mongoose, { Schema, Document } from 'mongoose';\n\ninterface IShoppingListItem extends Document {\n  name: string;\n  quantity: number;\n  unit: string;\n  category: string;\n  estimatedPrice: number;\n  recipeIds: string[];\n  notes?: string;\n}\n\ninterface IShoppingList extends Document {\n  userId: string;\n  weekNumber: number;\n  items: IShoppingListItem[];\n  totalEstimatedCost: number;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nconst ShoppingListItemSchema = new Schema({\n  name: { type: String, required: true },\n  quantity: { type: Number, required: true },\n  unit: { type: String, required: true },\n  category: { \n    type: String, \n    enum: ['produce', 'proteins', 'dairy', 'pantry', 'frozen', 'spices', 'other'],\n    required: true \n  },\n  estimatedPrice: { type: Number, required: true },\n  recipeIds: [{ type: String }],\n  notes: { type: String }\n});\n\nconst ShoppingListSchema = new Schema({\n  userId: { type: String, required: true, index: true },\n  weekNumber: { type: Number, required: true, min: 1, max: 6 },\n  items: [ShoppingListItemSchema],\n  totalEstimatedCost: { type: Number, required: true },\n  createdAt: { type: Date, default: Date.now },\n  updatedAt: { type: Date, default: Date.now }\n});\n\n// Create compound index for faster lookups\nShoppingListSchema.index({ userId: 1, weekNumber: 1 }, { unique: true });\n\nexport const ShoppingList = mongoose.model<IShoppingList>('ShoppingList', ShoppingListSchema);\n```",
        "testStrategy": "## Test Strategy\n\n### 1. Unit Tests\n- Test the shopping list generator service:\n\n```typescript\ndescribe('ShoppingListGeneratorService', () => {\n  let service: ShoppingListGeneratorService;\n  let mockMealPlanService: jest.Mocked<MealPlanService>;\n  let mockIngredientService: jest.Mocked<IngredientService>;\n  let mockPriceEstimationService: jest.Mocked<PriceEstimationService>;\n  \n  beforeEach(() => {\n    mockMealPlanService = {\n      getMealPlanForWeek: jest.fn()\n    } as any;\n    \n    mockIngredientService = {\n      getCategoryForIngredient: jest.fn(),\n      getStandardUnitForIngredient: jest.fn(),\n      convertUnits: jest.fn(),\n      getCommonPackagingSizes: jest.fn()\n    } as any;\n    \n    mockPriceEstimationService = {\n      estimatePrice: jest.fn()\n    } as any;\n    \n    service = new ShoppingListGeneratorService(\n      mockMealPlanService,\n      mockIngredientService,\n      mockPriceEstimationService\n    );\n  });\n  \n  test('should generate shopping list from meal plan', async () => {\n    // Mock meal plan data\n    const mockMealPlan = {\n      days: [\n        {\n          meals: [\n            {\n              recipe: {\n                id: 'recipe1',\n                ingredients: [\n                  { name: 'Chicken Breast', quantity: 300, unit: 'g' },\n                  { name: 'Olive Oil', quantity: 15, unit: 'ml' }\n                ]\n              }\n            },\n            {\n              recipe: {\n                id: 'recipe2',\n                ingredients: [\n                  { name: 'Chicken Breast', quantity: 200, unit: 'g' },\n                  { name: 'Rice', quantity: 100, unit: 'g' }\n                ]\n              }\n            }\n          ]\n        }\n      ]\n    };\n    \n    mockMealPlanService.getMealPlanForWeek.mockResolvedValue(mockMealPlan);\n    mockIngredientService.getCategoryForIngredient.mockImplementation((name) => {\n      if (name === 'chicken breast') return 'proteins';\n      if (name === 'olive oil') return 'pantry';\n      if (name === 'rice') return 'pantry';\n      return 'other';\n    });\n    mockIngredientService.getStandardUnitForIngredient.mockReturnValue('g');\n    mockIngredientService.convertUnits.mockImplementation((qty) => qty);\n    mockPriceEstimationService.estimatePrice.mockImplementation((name, qty) => {\n      if (name === 'chicken breast') return qty * 0.12;\n      if (name === 'olive oil') return qty * 0.08;\n      if (name === 'rice') return qty * 0.02;\n      return 0;\n    });\n    \n    const result = await service.generateWeeklyShoppingList('user123', 1);\n    \n    // Verify the shopping list has the correct items\n    expect(result.userId).toBe('user123');\n    expect(result.weekNumber).toBe(1);\n    expect(result.items.length).toBe(3);\n    \n    // Verify chicken quantities were combined\n    const chickenItem = result.items.find(item => item.name === 'chicken breast');\n    expect(chickenItem).toBeDefined();\n    expect(chickenItem?.quantity).toBe(500);\n    expect(chickenItem?.recipeIds).toContain('recipe1');\n    expect(chickenItem?.recipeIds).toContain('recipe2');\n    \n    // Verify total cost calculation\n    expect(result.totalEstimatedCost).toBeCloseTo(500 * 0.12 + 15 * 0.08 + 100 * 0.02);\n  });\n});\n\ndescribe('QuantityOptimizer', () => {\n  let optimizer: QuantityOptimizer;\n  let mockIngredientService: jest.Mocked<IngredientService>;\n  \n  beforeEach(() => {\n    mockIngredientService = {\n      getCommonPackagingSizes: jest.fn()\n    } as any;\n    \n    mockIngredientService.getCommonPackagingSizes.mockReturnValue(new Map([\n      ['chicken breast', [250, 500, 1000]],\n      ['rice', [500, 1000, 2000]]\n    ]));\n    \n    optimizer = new QuantityOptimizer(mockIngredientService);\n  });\n  \n  test('should optimize quantities to reduce waste', () => {\n    const shoppingList = {\n      id: 'list1',\n      userId: 'user123',\n      weekNumber: 1,\n      items: [\n        {\n          id: 'item1',\n          name: 'chicken breast',\n          quantity: 650,\n          unit: 'g',\n          category: 'proteins',\n          estimatedPrice: 78,\n          recipeIds: ['recipe1', 'recipe2']\n        },\n        {\n          id: 'item2',\n          name: 'rice',\n          quantity: 450,\n          unit: 'g',\n          category: 'pantry',\n          estimatedPrice: 9,\n          recipeIds: ['recipe2']\n        }\n      ],\n      totalEstimatedCost: 87,\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n    \n    const result = optimizer.optimizeQuantities(shoppingList);\n    \n    // Chicken should be rounded up to 1000g (next available package size)\n    const chickenItem = result.items.find(item => item.name === 'chicken breast');\n    expect(chickenItem?.quantity).toBe(1000);\n    expect(chickenItem?.notes).toContain('Rounded up to reduce waste');\n    \n    // Rice should be rounded up to 500g\n    const riceItem = result.items.find(item => item.name === 'rice');\n    expect(riceItem?.quantity).toBe(500);\n    \n    // Total cost should be updated\n    expect(result.totalEstimatedCost).toBeGreaterThan(shoppingList.totalEstimatedCost);\n  });\n});\n\ndescribe('PriceEstimationService', () => {\n  let service: PriceEstimationService;\n  \n  beforeEach(() => {\n    service = new PriceEstimationService();\n  });\n  \n  test('should estimate prices based on ingredient database', () => {\n    // Test known ingredients\n    expect(service.estimatePrice('chicken breast', 500, 'g')).toBeCloseTo(60); // 500g * 0.12 DKK/g\n    expect(service.estimatePrice('olive oil', 100, 'ml')).toBeCloseTo(8); // 100ml * 0.08 DKK/ml\n    \n    // Test unknown ingredients (should use category-based fallback)\n    expect(service.estimatePrice('unknown vegetable', 300, 'g')).toBeGreaterThan(0);\n  });\n});\n```\n\n### 2. Integration Tests\n- Test the API endpoints and database interactions:\n\n```typescript\ndescribe('Shopping List API Endpoints', () => {\n  let app;\n  let testServer;\n  let testDb;\n  \n  beforeAll(async () => {\n    // Set up test database and server\n    testDb = await setupTestDatabase();\n    app = createTestApp();\n    testServer = app.listen(0);\n  });\n  \n  afterAll(async () => {\n    await testServer.close();\n    await testDb.close();\n  });\n  \n  test('GET /api/shopping-lists/:userId/week/:weekNumber should return a shopping list', async () => {\n    // Create test user and meal plan in the database\n    const userId = 'test-user-123';\n    await createTestMealPlan(testDb, userId, 1);\n    \n    const response = await request(app)\n      .get(`/api/shopping-lists/${userId}/week/1`)\n      .set('Accept', 'application/json');\n    \n    expect(response.status).toBe(200);\n    expect(response.body).toHaveProperty('items');\n    expect(response.body).toHaveProperty('totalEstimatedCost');\n    expect(response.body.userId).toBe(userId);\n    expect(response.body.weekNumber).toBe(1);\n  });\n  \n  test('GET /api/shopping-lists/:userId/full-plan should return shopping lists for all weeks', async () => {\n    const userId = 'test-user-456';\n    \n    // Create test meal plans for all 6 weeks\n    for (let week = 1; week <= 6; week++) {\n      await createTestMealPlan(testDb, userId, week);\n    }\n    \n    const response = await request(app)\n      .get(`/api/shopping-lists/${userId}/full-plan`)\n      .set('Accept', 'application/json');\n    \n    expect(response.status).toBe(200);\n    expect(Array.isArray(response.body)).toBe(true);\n    expect(response.body.length).toBe(6);\n    \n    // Verify each week's shopping list\n    for (let i = 0; i < 6; i++) {\n      expect(response.body[i].weekNumber).toBe(i + 1);\n      expect(response.body[i].userId).toBe(userId);\n      expect(response.body[i]).toHaveProperty('items');\n    }\n  });\n});\n```\n\n### 3. Frontend Component Tests\n- Test the React components:\n\n```typescript\nimport { render, screen, waitFor } from '@testing-library/react';\nimport { ShoppingListView } from '../components/ShoppingListView';\nimport fetchMock from 'jest-fetch-mock';\n\ndescribe('ShoppingListView', () => {\n  beforeEach(() => {\n    fetchMock.resetMocks();\n  });\n  \n  test('should display loading state initially', () => {\n    render(<ShoppingListView userId=\"user123\" weekNumber={1} />);\n    expect(screen.getByText('Loading shopping list...')).toBeInTheDocument();\n  });\n  \n  test('should display shopping list when data is loaded', async () => {\n    const mockShoppingList = {\n      id: 'list1',\n      userId: 'user123',\n      weekNumber: 1,\n      items: [\n        {\n          id: 'item1',\n          name: 'Chicken Breast',\n          quantity: 500,\n          unit: 'g',\n          category: 'proteins',\n          estimatedPrice: 60,\n          recipeIds: ['recipe1']\n        },\n        {\n          id: 'item2',\n          name: 'Spinach',\n          quantity: 200,\n          unit: 'g',\n          category: 'produce',\n          estimatedPrice: 10,\n          recipeIds: ['recipe1']\n        }\n      ],\n      totalEstimatedCost: 70,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    };\n    \n    fetchMock.mockResponseOnce(JSON.stringify(mockShoppingList));\n    \n    render(<ShoppingListView userId=\"user123\" weekNumber={1} />);\n    \n    await waitFor(() => {\n      expect(screen.getByText('Shopping List for Week 1')).toBeInTheDocument();\n    });\n    \n    // Check category headers\n    expect(screen.getByText('Proteins')).toBeInTheDocument();\n    expect(screen.getByText('Produce')).toBeInTheDocument();\n    \n    // Check items\n    expect(screen.getByText('Chicken Breast')).toBeInTheDocument();\n    expect(screen.getByText('Spinach')).toBeInTheDocument();\n    \n    // Check total cost\n    expect(screen.getByText('Estimated Total: 70.00 DKK')).toBeInTheDocument();\n  });\n  \n  test('should display error message when fetch fails', async () => {\n    fetchMock.mockRejectOnce(new Error('Network error'));\n    \n    render(<ShoppingListView userId=\"user123\" weekNumber={1} />);\n    \n    await waitFor(() => {\n      expect(screen.getByText('Error: Network error')).toBeInTheDocument();\n    });\n  });\n});\n```\n\n### 4. End-to-End Tests\n- Test the complete shopping list generation flow:\n\n```typescript\ndescribe('Shopping List Generation E2E', () => {\n  let browser;\n  let page;\n  \n  beforeAll(async () => {\n    browser = await puppeteer.launch();\n  });\n  \n  afterAll(async () => {\n    await browser.close();\n  });\n  \n  beforeEach(async () => {\n    page = await browser.newPage();\n    // Log in and set up test data\n    await page.goto('http://localhost:3000/login');\n    await page.type('input[name=\"email\"]', 'test@example.com');\n    await page.type('input[name=\"password\"]', 'password123');\n    await page.click('button[type=\"submit\"]');\n    await page.waitForNavigation();\n  });\n  \n  test('should generate and display a shopping list', async () => {\n    // Navigate to meal plan page\n    await page.goto('http://localhost:3000/meal-plan');\n    \n    // Select week 1\n    await page.click('button[data-week=\"1\"]');\n    \n    // Click on shopping list button\n    await page.click('button[data-testid=\"generate-shopping-list\"]');\n    \n    // Wait for shopping list to load\n    await page.waitForSelector('.shopping-list');\n    \n    // Verify shopping list content\n    const pageTitle = await page.$eval('h2', el => el.textContent);\n    expect(pageTitle).toBe('Shopping List for Week 1');\n    \n    // Check if categories are displayed\n    const categories = await page.$$eval('.category-section h3', els => els.map(el => el.textContent));\n    expect(categories).toContain('Produce');\n    expect(categories).toContain('Proteins');\n    \n    // Check if at least one item is displayed\n    const itemCount = await page.$$eval('.shopping-item', items => items.length);\n    expect(itemCount).toBeGreaterThan(0);\n    \n    // Check if total cost is displayed\n    const totalCost = await page.$eval('.total-cost', el => el.textContent);\n    expect(totalCost).toContain('Estimated Total:');\n    expect(totalCost).toContain('DKK');\n  });\n  \n  test('should optimize quantities to reduce waste', async () => {\n    await page.goto('http://localhost:3000/shopping-list/1');\n    \n    // Wait for shopping list to load\n    await page.waitForSelector('.shopping-list');\n    \n    // Check if there are notes about rounded quantities\n    const notes = await page.$$eval('.item-notes', els => els.map(el => el.textContent));\n    const hasRoundingNote = notes.some(note => note.includes('Rounded up to reduce waste'));\n    \n    expect(hasRoundingNote).toBe(true);\n  });\n});\n```\n\n### 5. Performance Testing\n- Test the performance of the shopping list generation system:\n\n```typescript\ndescribe('Shopping List Generation Performance', () => {\n  test('should generate shopping list within acceptable time', async () => {\n    const shoppingListService = new ShoppingListGeneratorService(\n      new MealPlanService(),\n      new IngredientService(),\n      new PriceEstimationService()\n    );\n    \n    const startTime = Date.now();\n    await shoppingListService.generateWeeklyShoppingList('performance-test-user', 1);\n    const endTime = Date.now();\n    \n    const executionTime = endTime - startTime;\n    console.log(`Shopping list generation took ${executionTime}ms`);\n    \n    // Shopping list generation should take less than 500ms\n    expect(executionTime).toBeLessThan(500);\n  });\n  \n  test('should handle large meal plans efficiently', async () => {\n    // Create a large test meal plan with many recipes and ingredients\n    const largeMealPlan = createLargeMealPlanForTesting();\n    \n    const mockMealPlanService = {\n      getMealPlanForWeek: jest.fn().mockResolvedValue(largeMealPlan)\n    };\n    \n    const shoppingListService = new ShoppingListGeneratorService(\n      mockMealPlanService as any,\n      new IngredientService(),\n      new PriceEstimationService()\n    );\n    \n    const startTime = Date.now();\n    await shoppingListService.generateWeeklyShoppingList('performance-test-user', 1);\n    const endTime = Date.now();\n    \n    const executionTime = endTime - startTime;\n    console.log(`Large shopping list generation took ${executionTime}ms`);\n    \n    // Even with a large meal plan, generation should be under 1 second\n    expect(executionTime).toBeLessThan(1000);\n  });\n});",
        "status": "pending",
        "dependencies": [
          4,
          5
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Ingredient Extraction and Normalization Service",
            "description": "Develop a service that extracts ingredients from meal plans and normalizes them by standardizing names, units, and quantities to prepare for shopping list generation.",
            "dependencies": [],
            "details": "Create an IngredientExtractionService that:\n- Extracts all ingredients from recipes in a meal plan\n- Normalizes ingredient names (e.g., 'Red Bell Pepper' and 'Bell Pepper, Red' are treated as the same)\n- Converts quantities to standard units (e.g., tbsp to ml, oz to g)\n- Handles ingredient substitutions and alternatives\n- Implements unit conversion utilities for different measurement systems\n- Creates a mapping between ingredient variations and their canonical forms\n- Provides methods to merge similar ingredients with different names",
            "status": "pending",
            "testStrategy": "- Test ingredient name normalization with various input formats\n- Test unit conversion accuracy across different measurement systems\n- Test extraction of ingredients from complex recipe structures\n- Test merging of similar ingredients\n- Mock meal plan data to verify complete extraction of all ingredients"
          },
          {
            "id": 2,
            "title": "Shopping List Consolidation and Categorization",
            "description": "Implement functionality to consolidate similar ingredients, categorize items by store sections, and optimize quantities to reduce food waste.",
            "dependencies": [
              "8.1"
            ],
            "details": "Develop a ShoppingListProcessor that:\n- Consolidates similar ingredients (e.g., combining 2 tomatoes from one recipe and 3 from another)\n- Categorizes items into logical store sections (produce, proteins, dairy, etc.)\n- Implements the QuantityOptimizer to adjust quantities based on common packaging sizes\n- Handles special cases like spices and pantry staples that may be used across multiple weeks\n- Provides smart rounding of quantities to reduce waste\n- Adds notes for items where quantities have been optimized\n- Sorts items within categories for easier shopping",
            "status": "pending",
            "testStrategy": "- Test consolidation of ingredients with same name but different units\n- Test categorization accuracy for various ingredient types\n- Test quantity optimization with different packaging size scenarios\n- Verify that optimized quantities never fall below required amounts\n- Test sorting functionality within categories"
          },
          {
            "id": 3,
            "title": "Price Estimation and Cost Analysis",
            "description": "Create a service to estimate costs of shopping list items using average prices, calculate total costs, and provide cost breakdown by category.",
            "dependencies": [
              "8.2"
            ],
            "details": "Implement a PriceEstimationService that:\n- Maintains a database of average prices for common ingredients\n- Estimates prices for items not in the database using category averages\n- Calculates total cost for the shopping list\n- Provides cost breakdown by category\n- Handles currency formatting and conversions\n- Updates price estimates based on quantity changes\n- Implements interfaces for future integration with actual store pricing APIs\n- Provides historical price tracking for recurring items",
            "status": "pending",
            "testStrategy": "- Test price calculation accuracy for items with known prices\n- Test fallback estimation for items not in the price database\n- Test total cost calculation with various shopping list compositions\n- Test currency formatting for different locales\n- Verify price updates when quantities change"
          },
          {
            "id": 4,
            "title": "Shopping List API and Database Integration",
            "description": "Develop API endpoints for shopping list operations and implement database persistence for shopping lists with MongoDB integration.",
            "dependencies": [
              "8.1",
              "8.2",
              "8.3"
            ],
            "details": "Create a complete API layer for shopping lists:\n- Implement RESTful endpoints for generating, retrieving, and updating shopping lists\n- Design MongoDB schemas for shopping list persistence\n- Create data access layer for shopping list operations\n- Implement endpoints for generating lists for specific weeks or the entire 6-week plan\n- Add functionality to mark items as purchased or modify quantities\n- Implement caching for frequently accessed shopping lists\n- Create database indexes for efficient queries\n- Add user authentication and authorization for shopping list access",
            "status": "pending",
            "testStrategy": "- Test API endpoints with various request parameters\n- Test database operations for creating and retrieving shopping lists\n- Test authentication and authorization for protected endpoints\n- Verify proper error handling for invalid requests\n- Test performance with large shopping lists\n- Test concurrent access patterns"
          },
          {
            "id": 5,
            "title": "Shopping List UI Components and User Experience",
            "description": "Design and implement React components for displaying, interacting with, and exporting shopping lists with features for printing, filtering, and sorting.",
            "dependencies": [
              "8.4"
            ],
            "details": "Develop frontend components for shopping list management:\n- Create ShoppingListView component with categorized display of items\n- Implement interactive features (checking off items, adjusting quantities)\n- Add filtering and sorting capabilities by category, price, or recipe\n- Design print-friendly layout for shopping lists\n- Implement export functionality (PDF, email, text)\n- Create mobile-responsive design for on-the-go shopping\n- Add visual indicators for optimized quantities\n- Implement drag-and-drop for reordering items\n- Create summary view with total cost and item count\n- Add accessibility features for screen readers",
            "status": "pending",
            "testStrategy": "- Test component rendering with various shopping list data\n- Test interactive features like checking items and adjusting quantities\n- Test print layout in different browsers\n- Test export functionality for different formats\n- Verify responsive design on different screen sizes\n- Test accessibility with screen readers and keyboard navigation"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-05T07:36:53.113Z",
      "updated": "2025-08-05T09:13:14.821Z",
      "description": "6-week personalized meal plan system with multiple dietary approaches"
    }
  },
  "functionalfoods-comprehensive": {
    "tasks": [
      {
        "id": 1,
        "title": "Debug and Fix Recipe Import Save Functionality",
        "description": "Investigate and resolve the issue with the recipe import system where recipes are processed correctly but fail to save to the database.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "**Root Cause Found:**\nThe database schema was missing several columns that the TypeScript interface expected:\n- `shortDescription`, `preparationTime`, `cookingTime`, `totalTime`\n- `metaTitle`, `metaDescription`, `mainCategory`, `subCategories`, `dietaryCategories`\n- `imageUrl`, `imageAlt`, `commonNames`, `isActive`, `createdAt`, `updatedAt`\n- `prepTimeISO`, `cookTimeISO`, `totalTimeISO`\n\n**Solution Implemented:**\n1. Updated the Supabase configuration to use the newer API keys\n2. Modified the `database-service.ts` to filter recipes and ingredients to only include columns that actually exist in the database\n3. Added conditional logic to include optional fields only if they exist\n4. The save functionality now works by excluding missing columns\n\n**Next Steps:**\n1. Update the database schema to add missing columns for full functionality\n2. Proceed with nutrition data integration\n\nTechnologies: Supabase JS Client v2.x, Next.js 14 API routes or server actions",
        "testStrategy": "**Testing Results:**\n- ✅ Database connection works\n- ✅ Basic recipe save works (with existing columns)\n- ✅ Basic ingredient save works\n- ✅ Import processing works correctly\n- ✅ Save functionality now works by filtering out missing columns\n\n**Additional Testing Needed:**\n1. Test with various recipe formats to ensure consistent saving\n2. Verify database entries after schema updates\n3. Test the entire import-to-save flow with more complex data\n4. Create integration tests that cover the full import process including the new filtering logic",
        "subtasks": [
          {
            "id": 1,
            "title": "Update Supabase configuration with newer API keys",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Modify database-service.ts to filter recipes and ingredients",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Add conditional logic for optional fields",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement column filtering for save operations",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Update database schema to add missing columns",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Document schema changes and filtering solution",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Create comprehensive tests for the updated save functionality",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Integrate Frida DTU Nutritional Data",
        "description": "Integrate the Frida DTU nutritional database with the recipe system to provide comprehensive nutritional information for all ingredients.",
        "status": "in-progress",
        "dependencies": [],
        "priority": "high",
        "details": "1. Parse the frida-nutritional-data.json file (53MB)\n2. Create a normalized database structure for efficient querying\n3. Implement a fuzzy matching algorithm to match ingredient strings with Frida data entries (consider using fuzzyset.js or similar)\n4. Create a mapping table to handle common variations of ingredient names\n5. Develop a fallback system for ingredients not found in the database\n6. Implement caching for frequently accessed nutritional data\n7. Create a background process to periodically update nutritional data\n8. Develop an admin interface for manual mapping of ingredients\n9. Implement unit conversion for nutritional values based on recipe quantities\n10. Ensure proper handling of composite ingredients\n\nData Structure Findings:\n- The Frida data is in long-form format with 137,946 total records\n- Each record represents a food item with a specific nutritional parameter\n- Contains 1,370 unique food items with nutritional data\n- Key parameters identified: Protein, Fedt (fat), Kulhydrat (carbs), C-vitamin, D-vitamin, B12-vitamin, Jern (iron), Kalcium (calcium), etc.\n\nTransformation Progress:\n- Created transformation script to convert long-form data to usable format\n- Successfully extracted calories data (100% coverage)\n- Identified correct parameter names for comprehensive nutrition extraction\n- Generated frida-transformed.json with normalized structure\n\nTechnologies: PostgreSQL JSON functions, pg-promise or Prisma for complex queries, fuzzyset.js v1.0.7+ for fuzzy matching",
        "testStrategy": "1. Verify data integrity after import\n2. Test fuzzy matching with various ingredient formats\n3. Benchmark query performance with large datasets\n4. Validate nutritional calculations against known values\n5. Test edge cases like unusual ingredients or measurements\n6. Create integration tests for the entire nutritional calculation pipeline\n7. Validate transformed data structure against original source\n8. Test parameter name mapping accuracy\n9. Verify nutritional value extraction completeness",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze Frida DTU data structure",
            "description": "Analyze the structure of the Frida DTU nutritional data to understand its format and organization.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create data transformation script",
            "description": "Develop a script to transform the long-form data (137,946 records) into a normalized structure for efficient use.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Extract nutritional parameters",
            "description": "Identify and extract all key nutritional parameters (Protein, Fedt, Kulhydrat, vitamins, minerals, etc.) from the dataset.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Generate normalized data file",
            "description": "Create frida-transformed.json with the normalized structure for integration with the recipe system.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Update transformation script with correct parameter names",
            "description": "Refine the transformation script to ensure all nutritional parameters are correctly named and extracted.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement fuzzy matching system for ingredient names",
            "description": "Develop a fuzzy matching algorithm to match ingredient strings with Frida data entries, handling variations in naming.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Integrate with existing ingredient system",
            "description": "Connect the transformed nutritional data with the current ingredient system in the recipe platform.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Implement caching for performance",
            "description": "Create a caching mechanism for frequently accessed nutritional data to improve query performance.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Add to import process for automatic nutrition matching",
            "description": "Integrate the nutritional data matching into the ingredient import process for automatic association.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Research latest nutritional data APIs and best practices using Context7",
            "description": "Use Context7 to research the latest nutritional data APIs, best practices for data transformation, and current standards for nutritional information integration. This will ensure we're using the most up-to-date approaches for the Frida DTU integration.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 2
          }
        ]
      },
      {
        "id": 3,
        "title": "Enhance Recipe Import with Nutritional Data Matching",
        "description": "Modify the recipe import system to automatically match ingredients with Frida nutritional data during the import process.",
        "details": "1. Extend the current import function to include nutritional data matching\n2. Implement a preprocessing step to standardize ingredient formats\n3. Create a batch processing system for efficient matching\n4. Develop a confidence scoring system for matches\n5. Implement a manual review interface for low-confidence matches\n6. Add nutritional data validation to ensure completeness\n7. Create a reporting system for unmatched ingredients\n8. Optimize the matching algorithm for performance with large imports\n9. Implement caching to improve repeated imports\n10. Add support for custom nutritional data entry\n\nTechnologies: Worker threads for batch processing, Redis or similar for caching, React Hook Form v7.x for manual review interface",
        "testStrategy": "1. Test with various recipe formats (JSON, CSV, etc.)\n2. Verify nutritional data accuracy after import\n3. Benchmark import performance with large batches\n4. Test the manual review process with edge cases\n5. Validate the confidence scoring system\n6. Create end-to-end tests for the entire import process",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Complete 6-Week Meal Plan Wizard Flow",
        "description": "Finalize the user profile collection wizard for the 6-week meal plan system, including dietary approach selection and preferences.",
        "details": "1. Design a multi-step form wizard using a state machine approach\n2. Implement form validation for each step\n3. Create UI components for dietary approach selection (7 approaches)\n4. Develop preference collection for allergies, dislikes, and cooking time\n5. Implement a progress indicator for the wizard\n6. Add persistence to allow users to continue later\n7. Create a summary review step before final submission\n8. Implement responsive design for all device sizes\n9. Add animations for transitions between steps\n10. Ensure accessibility compliance throughout the wizard\n\nTechnologies: XState v4.x for state management, React Hook Form v7.x for validation, Framer Motion v10.x for animations, Zod v3.x for schema validation",
        "testStrategy": "1. Test form validation with various inputs\n2. Verify state transitions in the wizard flow\n3. Test persistence across page refreshes\n4. Conduct usability testing with real users\n5. Verify accessibility with automated tools and manual testing\n6. Test responsive design across device sizes",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Develop Meal Plan Generation Algorithm",
        "description": "Create an algorithm to generate personalized 6-week meal plans based on user profiles, dietary approaches, and nutritional requirements.",
        "details": "1. Implement macro calculation service based on user profile data\n2. Create a recipe filtering system based on dietary approaches\n3. Develop a meal distribution algorithm for balanced weekly plans\n4. Implement variety constraints to prevent repetition\n5. Create nutritional balancing across days and weeks\n6. Add support for user preferences and restrictions\n7. Implement meal complexity distribution throughout the week\n8. Add seasonal recipe weighting for relevant ingredients\n9. Create fallback mechanisms for edge cases\n10. Optimize algorithm performance for quick generation\n\nTechnologies: Linear programming with JavaScript-simplex or similar, Worker threads for background processing, Redis for caching generated plans",
        "testStrategy": "1. Test algorithm with various user profiles\n2. Verify nutritional balance in generated plans\n3. Benchmark algorithm performance\n4. Test edge cases like limited recipe availability\n5. Validate meal variety and distribution\n6. Create unit tests for individual algorithm components",
        "priority": "medium",
        "dependencies": [
          2,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement PDF Generation for Meal Plans",
        "description": "Develop a system to generate downloadable PDF documents for 6-week meal plans, including recipes, shopping lists, and nutritional information.",
        "details": "1. Select and integrate a PDF generation library (jsPDF recommended)\n2. Design PDF templates for meal plans with consistent branding\n3. Implement dynamic content generation based on meal plan data\n4. Create weekly and daily views within the PDF\n5. Add recipe details with images and instructions\n6. Generate consolidated shopping lists by week\n7. Include nutritional summaries and charts\n8. Implement server-side PDF generation for complex documents\n9. Add customization options for PDF output\n10. Optimize for print quality and file size\n\nTechnologies: jsPDF v2.5.x, html2canvas v1.4.x for complex layouts, chart.js v4.x for nutritional visualizations, Sharp for image processing",
        "testStrategy": "1. Verify PDF generation with various meal plans\n2. Test PDF rendering across different devices and browsers\n3. Validate content accuracy in generated PDFs\n4. Test performance with large meal plans\n5. Verify print quality and layout\n6. Test PDF accessibility features",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Create Shopping List Generation System",
        "description": "Develop a system to generate consolidated shopping lists from meal plans, with intelligent grouping and categorization of ingredients.",
        "details": "1. Create an ingredient consolidation algorithm to combine similar items\n2. Implement unit conversion and normalization\n3. Develop categorization by supermarket sections\n4. Add support for weekly or full plan shopping lists\n5. Implement quantity rounding for practical shopping\n6. Create a user interface for list customization\n7. Add the ability to remove or adjust items\n8. Implement list sharing functionality\n9. Create print-friendly formats\n10. Add integration with the PDF generation system\n\nTechnologies: JavaScript array manipulation, Lodash v4.x for utility functions, React context for state management, unit-conversion library for measurements",
        "testStrategy": "1. Test consolidation with various ingredient combinations\n2. Verify unit conversion accuracy\n3. Test categorization with diverse ingredients\n4. Validate quantity calculations\n5. Test user customization features\n6. Create integration tests with meal planning system",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Nutritional Assessment System",
        "description": "Develop a system to assess potential nutritional deficiencies based on user-reported symptoms and provide personalized recommendations.",
        "details": "1. Create a comprehensive symptom questionnaire\n2. Develop a mapping between symptoms and potential deficiencies\n3. Implement a scoring algorithm for deficiency likelihood\n4. Create personalized recommendation engine\n5. Develop visualization of assessment results\n6. Implement progress tracking over time\n7. Add integration with meal planning for targeted nutrition\n8. Create educational content for each deficiency\n9. Implement follow-up assessment scheduling\n10. Add export functionality for healthcare providers\n\nTechnologies: Survey.js v1.9.x for questionnaires, D3.js v7.x for visualizations, Next.js API routes for assessment processing",
        "testStrategy": "1. Validate assessment algorithm with known cases\n2. Test recommendation relevance and accuracy\n3. Verify visualization correctness\n4. Test integration with meal planning\n5. Conduct usability testing with target users\n6. Verify data privacy and security",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Develop AI SMS Function for User Registration",
        "description": "Implement an SMS-based user registration system with minimal design requirements and automated welcome messages.",
        "details": "1. Research and select a Danish SMS service provider (e.g., GatewayAPI, Twilio)\n2. Implement SMS verification code generation\n3. Create API endpoints for SMS verification\n4. Develop user registration flow via SMS\n5. Implement rate limiting to prevent abuse\n6. Create automated welcome message templates\n7. Add integration with existing user system\n8. Implement error handling for failed SMS delivery\n9. Add analytics for conversion tracking\n10. Create admin interface for SMS template management\n\nTechnologies: GatewayAPI or Twilio for SMS, Next.js API routes for backend logic, Supabase Auth for user management, rate-limiter-flexible for protection",
        "testStrategy": "1. Test SMS delivery to various carriers\n2. Verify verification code validation\n3. Test rate limiting functionality\n4. Validate user creation in database\n5. Test error handling scenarios\n6. Conduct end-to-end registration flow testing",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Create Weekly Digital Meal Planner Interface",
        "description": "Develop an interactive weekly meal planner interface as part of the budget function, allowing users to plan meals and generate shopping lists.",
        "details": "1. Design a drag-and-drop interface for meal assignment\n2. Implement calendar view with daily meal slots\n3. Create recipe search and filtering within the planner\n4. Develop real-time nutritional summary updates\n5. Implement meal plan saving and loading\n6. Add template functionality for quick planning\n7. Create responsive design for all devices\n8. Implement print functionality\n9. Add sharing capabilities\n10. Integrate with shopping list generation\n\nTechnologies: react-beautiful-dnd v13.x for drag-and-drop, FullCalendar v6.x for calendar view, React Query v4.x for data fetching, Tailwind CSS for responsive design",
        "testStrategy": "1. Test drag-and-drop functionality across devices\n2. Verify nutritional calculations update correctly\n3. Test save and load functionality\n4. Validate template application\n5. Test responsive design across breakpoints\n6. Conduct usability testing with target users",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement Price Comparison Across Danish Supermarkets",
        "description": "Develop a system to compare prices of ingredients across Danish supermarkets and optimize shopping lists for cost.",
        "details": "1. Research and identify APIs for major Danish supermarkets (Netto, Føtex, Bilka, Rema 1000, etc.)\n2. Implement API integrations for price fetching\n3. Create a normalized product database for matching\n4. Develop a price comparison algorithm\n5. Implement store preference settings\n6. Create visualization of potential savings\n7. Add support for store-specific shopping lists\n8. Implement caching for price data\n9. Create scheduled updates for price changes\n10. Add user feedback for price accuracy\n\nTechnologies: Node.js workers for API polling, PostgreSQL for price database, Redis for caching, React for interactive visualizations",
        "testStrategy": "1. Test API integrations with each supermarket\n2. Verify price comparison accuracy\n3. Test caching and update mechanisms\n4. Validate shopping list optimization\n5. Benchmark performance with large shopping lists\n6. Test error handling for API failures",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Develop Cost Optimization Recommendations",
        "description": "Create a system to provide intelligent cost optimization recommendations for meal plans and shopping lists.",
        "details": "1. Implement ingredient substitution suggestions\n2. Develop seasonal ingredient recommendations\n3. Create bulk purchase opportunity identification\n4. Implement store selection optimization\n5. Add recipe alternatives with similar nutrition but lower cost\n6. Develop visualization of potential savings\n7. Create user preference settings for optimization priorities\n8. Implement weekly special detection\n9. Add historical price tracking\n10. Create notification system for price drops\n\nTechnologies: Machine learning with TensorFlow.js for pattern recognition, Chart.js for savings visualization, Web Push API for notifications",
        "testStrategy": "1. Test substitution relevance and accuracy\n2. Verify cost calculations for different scenarios\n3. Test optimization with various user preferences\n4. Validate seasonal recommendations\n5. Test notification system\n6. Conduct user testing for recommendation quality",
        "priority": "low",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Set Up Make.com Automation for Recipe Generation",
        "description": "Establish an automated workflow using Make.com to generate recipes using AI and prepare them for import into the system.",
        "details": "1. Create a Make.com account and set up the project\n2. Design workflow for recipe generation using AI APIs (OpenAI, Claude, etc.)\n3. Implement structured output formatting for generated recipes\n4. Set up Midjourney integration for image generation\n5. Create validation steps for recipe quality\n6. Implement batch processing for efficiency\n7. Set up error handling and notifications\n8. Create scheduling for automated generation\n9. Implement output to JSON format compatible with import system\n10. Add customization options for recipe types and dietary approaches\n\nTechnologies: Make.com (formerly Integromat), OpenAI API, Midjourney API, JSON Schema for validation",
        "testStrategy": "1. Test recipe generation quality and variety\n2. Verify image generation appropriateness\n3. Validate JSON output against import requirements\n4. Test error handling scenarios\n5. Verify scheduling reliability\n6. Conduct manual review of generated content",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement Quality Control for AI-Generated Recipes",
        "description": "Develop a system to validate and ensure quality of AI-generated recipes before they are added to the database.",
        "details": "1. Create a validation pipeline for generated recipes\n2. Implement nutritional coherence checking\n3. Develop ingredient-instruction consistency validation\n4. Create cooking time and complexity estimation\n5. Implement duplicate detection\n6. Add manual review interface for flagged recipes\n7. Create batch approval workflow\n8. Implement feedback loop to improve generation\n9. Add tagging and categorization automation\n10. Create quality metrics dashboard\n\nTechnologies: Node.js for validation scripts, React for review interface, PostgreSQL for tracking, TensorFlow.js for advanced validation",
        "testStrategy": "1. Test validation with known good and bad recipes\n2. Verify duplicate detection accuracy\n3. Test nutritional validation against reference data\n4. Validate review interface usability\n5. Test batch processing performance\n6. Verify metrics accuracy",
        "priority": "medium",
        "dependencies": [
          13
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Redesign Frontend User Interface",
        "description": "Implement a complete frontend redesign to create a modern, amazing user experience with improved navigation and visual design.",
        "details": "1. Create a comprehensive design system with components\n2. Implement atomic design principles for scalability\n3. Develop responsive layouts for all breakpoints\n4. Create animation and transition system\n5. Implement dark mode support\n6. Optimize for accessibility (WCAG 2.1 AA compliance)\n7. Create improved navigation patterns\n8. Implement performance optimizations\n9. Add microinteractions for engagement\n10. Create consistent typography and color systems\n\nTechnologies: Tailwind CSS v3.x, Headless UI v1.7.x, Framer Motion v10.x for animations, Storybook v7.x for component documentation",
        "testStrategy": "1. Test responsive design across devices\n2. Verify accessibility with automated tools and manual testing\n3. Conduct usability testing with target users\n4. Test performance metrics (Core Web Vitals)\n5. Verify cross-browser compatibility\n6. Test dark mode implementation",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Optimize Image Loading and Processing",
        "description": "Enhance image loading performance and implement advanced image processing for recipe images.",
        "details": "1. Implement responsive image loading with Next.js Image\n2. Create image processing pipeline for uploads\n3. Implement WebP and AVIF format conversion\n4. Add lazy loading for off-screen images\n5. Implement image placeholders for fast loading\n6. Create image optimization service\n7. Add automatic image compression\n8. Implement content-aware cropping\n9. Create image caching strategy\n10. Add image preloading for critical content\n\nTechnologies: Next.js Image component, Sharp v0.32.x for processing, Cloudinary or similar for advanced transformations, Intersection Observer API for lazy loading",
        "testStrategy": "1. Benchmark image loading performance\n2. Test responsive image behavior across devices\n3. Verify image quality after optimization\n4. Test lazy loading effectiveness\n5. Validate placeholder implementation\n6. Measure bandwidth savings",
        "priority": "medium",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Implement SEO Optimization",
        "description": "Enhance the platform's search engine optimization to improve visibility and organic traffic.",
        "details": "1. Implement dynamic metadata generation\n2. Create XML sitemap generation\n3. Add structured data (Schema.org) for recipes\n4. Implement canonical URLs\n5. Create SEO-friendly URL structure\n6. Add Open Graph and Twitter card metadata\n7. Implement breadcrumb navigation\n8. Create SEO performance monitoring\n9. Add automated content analysis for SEO improvements\n10. Implement server-side rendering for critical pages\n\nTechnologies: Next.js metadata API, next-sitemap v4.x, Schema.org JSON-LD, next-seo v6.x for metadata management",
        "testStrategy": "1. Validate structured data with Google testing tool\n2. Test sitemap generation and submission\n3. Verify metadata across different page types\n4. Test canonical URL implementation\n5. Validate Open Graph tags with debugging tools\n6. Monitor search console for issues",
        "priority": "medium",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Set Up Analytics and Performance Monitoring",
        "description": "Implement comprehensive analytics and performance monitoring to track user engagement and system performance.",
        "details": "1. Set up Google Analytics 4 integration\n2. Implement custom event tracking\n3. Create conversion funnels for key user journeys\n4. Set up performance monitoring with Vercel Analytics\n5. Implement error tracking with Sentry\n6. Create custom dashboards for key metrics\n7. Add user flow visualization\n8. Implement A/B testing framework\n9. Create automated performance reporting\n10. Add real user monitoring (RUM)\n\nTechnologies: Google Analytics 4, Vercel Analytics, Sentry v7.x for error tracking, PostHog or similar for user flows, next/third-parties for optimized loading",
        "testStrategy": "1. Verify event tracking accuracy\n2. Test error capturing and reporting\n3. Validate performance metric collection\n4. Test A/B test implementation\n5. Verify dashboard data accuracy\n6. Test analytics in various user scenarios",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Implement GDPR Compliance for Danish Market",
        "description": "Ensure the platform is fully compliant with GDPR regulations specific to the Danish market.",
        "details": "1. Create comprehensive privacy policy\n2. Implement cookie consent management\n3. Create data export functionality\n4. Implement right to be forgotten\n5. Add data processing records\n6. Create data breach notification system\n7. Implement data minimization practices\n8. Add user consent tracking\n9. Create admin tools for GDPR requests\n10. Implement data retention policies\n\nTechnologies: Cookie Consent Manager (like Cookiebot or OneTrust), Next.js middleware for consent checking, Supabase RLS for data access control",
        "testStrategy": "1. Verify cookie blocking before consent\n2. Test data export completeness\n3. Validate account deletion functionality\n4. Test consent recording and tracking\n5. Verify privacy policy accessibility\n6. Conduct compliance audit with checklist",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Develop Premium Feature Access Control",
        "description": "Implement a system to manage access to premium features and protect premium content.",
        "details": "1. Create subscription management system\n2. Implement feature access control\n3. Develop premium content protection\n4. Create payment processing integration\n5. Implement trial period functionality\n6. Add subscription analytics\n7. Create upgrade prompts and journeys\n8. Implement gift subscription functionality\n9. Add subscription management interface\n10. Create automated renewal notifications\n\nTechnologies: Stripe API v2023-10-16 for payments, Supabase RLS for access control, JWT for feature authorization, React Query for state management",
        "testStrategy": "1. Test payment processing end-to-end\n2. Verify access control for premium features\n3. Test subscription lifecycle (create, update, cancel)\n4. Validate trial period functionality\n5. Test upgrade flows\n6. Verify renewal notifications",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Implement Progress Tracking for Meal Plans",
        "description": "Develop a system to track user progress through meal plans and provide insights and encouragement.",
        "details": "1. Create meal completion tracking\n2. Implement streak and achievement system\n3. Develop progress visualization\n4. Create personalized insights generation\n5. Implement reminder system\n6. Add social sharing of achievements\n7. Create weekly summary reports\n8. Implement goal setting functionality\n9. Add before/after tracking\n10. Create motivation and encouragement system\n\nTechnologies: React Query for state management, Chart.js for visualizations, Web Push API for reminders, localStorage for offline tracking",
        "testStrategy": "1. Test progress tracking accuracy\n2. Verify achievement unlocking\n3. Test reminder functionality\n4. Validate insight generation\n5. Test goal setting and tracking\n6. Verify report generation",
        "priority": "low",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Set Up Production Environment on Vercel",
        "description": "Configure and deploy the application to Vercel production environment with proper CI/CD pipeline.",
        "details": "1. Set up Vercel project configuration\n2. Configure environment variables\n3. Implement CI/CD pipeline with GitHub\n4. Set up preview deployments for PRs\n5. Configure custom domain and SSL\n6. Implement caching strategies\n7. Set up monitoring and alerts\n8. Create deployment documentation\n9. Implement database backup strategy\n10. Configure scaling parameters\n\nTechnologies: Vercel CLI, GitHub Actions, Vercel Edge Config, Vercel Cron Jobs, Supabase backup tools",
        "testStrategy": "1. Test deployment process end-to-end\n2. Verify environment variable configuration\n3. Test preview deployments\n4. Validate custom domain and SSL setup\n5. Test monitoring and alerts\n6. Verify backup and restore process",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Implement Automated Recipe Generation with AI",
        "description": "Develop a system to automatically generate high-quality recipes using AI, targeting an expansion to 5000+ recipes.",
        "details": "1. Research and select appropriate AI models (GPT-4, Claude, etc.)\n2. Create prompt engineering for recipe generation\n3. Implement structured output formatting\n4. Develop quality control filters\n5. Create batch generation system\n6. Implement nutritional analysis integration\n7. Add image generation with Midjourney\n8. Create category and tag assignment\n9. Implement duplicate detection\n10. Add human review workflow\n\nTechnologies: OpenAI API, Anthropic Claude API, Midjourney API, Node.js for orchestration, PostgreSQL for tracking",
        "testStrategy": "1. Test recipe quality and variety\n2. Verify nutritional accuracy\n3. Test image appropriateness\n4. Validate structured output format\n5. Test duplicate detection\n6. Verify category assignment accuracy",
        "priority": "medium",
        "dependencies": [
          14
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Create Mobile-Optimized User Experience",
        "description": "Enhance the mobile experience with specific optimizations for small screens and touch interfaces.",
        "details": "1. Implement mobile-specific navigation patterns\n2. Create touch-friendly UI components\n3. Optimize for various screen sizes\n4. Implement offline functionality with PWA\n5. Add mobile-specific gestures\n6. Optimize performance for mobile devices\n7. Create mobile-first content layouts\n8. Implement app install prompts\n9. Add mobile-specific features (camera integration, etc.)\n10. Create responsive image strategies\n\nTechnologies: Progressive Web App (PWA) features, Service Workers, use-gesture hook for touch interactions, next-pwa for PWA setup",
        "testStrategy": "1. Test on various mobile devices and screen sizes\n2. Verify touch interactions and gestures\n3. Test offline functionality\n4. Validate performance on low-end devices\n5. Test PWA installation flow\n6. Verify responsive behavior",
        "priority": "medium",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Implement Multi-Language Support",
        "description": "Add support for multiple languages, with initial focus on Danish and English, to expand the platform's reach.",
        "details": "1. Implement i18n framework with next-intl\n2. Create translation workflow and management\n3. Extract UI strings for translation\n4. Implement language detection and switching\n5. Add locale-specific formatting (dates, numbers, etc.)\n6. Create language preference persistence\n7. Implement SEO for multiple languages\n8. Add right-to-left (RTL) support for future languages\n9. Create translation quality assurance process\n10. Implement automated translation suggestions\n\nTechnologies: next-intl v2.x, Crowdin or similar for translation management, Intl API for formatting, next-i18n-router for routing",
        "testStrategy": "1. Test language switching functionality\n2. Verify translations in context\n3. Test locale-specific formatting\n4. Validate SEO elements for each language\n5. Test RTL layout if implemented\n6. Verify persistence of language preference",
        "priority": "low",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Integrate Context7 for Documentation and Best Practices",
        "description": "Implement Context7 integration to provide developers with up-to-date documentation, API references, and best practices for all technologies used in the project.",
        "details": "1. Research and evaluate Context7 implementation options for our tech stack\n2. Set up Context7 account and configure team access permissions\n3. Create custom documentation collections for project-specific technologies (Next.js, Supabase, TypeScript, Tailwind CSS)\n4. Implement Context7 browser extension integration for the development team\n5. Configure IDE plugins for VS Code and other editors used by the team\n6. Set up automated documentation updates and notifications\n7. Create custom documentation sections for internal APIs and components\n8. Implement search functionality across all documentation sources\n9. Configure Context7 to highlight best practices and security considerations\n10. Create onboarding documentation for new team members on using Context7\n11. Set up analytics to track documentation usage and identify knowledge gaps\n12. Integrate Context7 with existing development workflows (GitHub, Slack)\n13. Implement documentation versioning to align with project releases\n14. Create a feedback mechanism for improving documentation quality",
        "testStrategy": "1. Verify Context7 integration works across all development environments\n2. Test documentation search functionality with various queries\n3. Validate that API references are accurate and up-to-date\n4. Confirm browser extensions and IDE plugins function correctly\n5. Test notification system for documentation updates\n6. Verify custom documentation sections are properly organized and accessible\n7. Conduct user testing with developers to ensure usability and effectiveness\n8. Test offline access capabilities for documentation\n9. Verify integration with existing tools (GitHub, Slack)\n10. Validate analytics tracking for documentation usage",
        "status": "pending",
        "dependencies": [
          22
        ],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-06T08:17:01.247Z",
      "updated": "2025-08-06T19:29:00.753Z",
      "description": "Tasks for functionalfoods-comprehensive context"
    }
  }
}